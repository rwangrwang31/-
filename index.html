<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NO GAME NO LIFE | DISBOARD SYSTEM</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+SC:wght@300;500;700&family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
    <style>
        /* ================= 0. 核心变量与全局设定 ================= */
        :root {
            --pink:#ff2a6d; --cyan:#05d9e8; --purple:#d905e8; --gold:#ffd700;
            --dark:#05010d; --glass:rgba(20,20,35,0.9); --border:rgba(255,255,255,0.1);
            --race-olddeus:#ffef5c;
            --race-phantasma:#e65cff;
            --race-elemental:#5ce6ff;
            --race-dragonia:#ff7c5c;
            --race-flugel:#ffb4ff;
            --race-demon:#ff6c9c;
            --race-fairy:#9cffd0;
            --race-dwarf:#ffc46c;
            --race-werabeast:#ff7aa8;
            --race-seiren:#5cd0ff;
            --race-dhampir:#b35cff;
            --race-elf:#7affb7;
            --race-angel:#ffe0ff;
            --race-goblin:#b5ff5c;
            --race-automaton:#9ad0ff;
            --race-imanity:#ffffff;
        }
        *{margin:0;padding:0;box-sizing:border-box;cursor:none;outline:none;user-select:none;}
        html{scroll-behavior:smooth;}
        body{background-color:var(--dark);color:white;font-family:'Noto Sans SC',sans-serif;height:100vh;overflow-x:hidden;}

        /* ================= 1. 动态光标 ================= */
        #cursor{width:25px;height:25px;border:2px solid var(--cyan);border-radius:50%;position:fixed;pointer-events:none;z-index:999999;transform:translate(-50%,-50%);transition:all .1s ease-out;mix-blend-mode:difference;}
        #cursor.hover{width:60px;height:60px;background:rgba(5,217,232,.2);border-color:var(--pink);}
        #cursor.click{transform:translate(-50%,-50%) scale(.8);border-width:4px;}
        ::-webkit-scrollbar{width:8px;}
        ::-webkit-scrollbar-thumb{background:linear-gradient(180deg,var(--pink),var(--purple),var(--cyan));border-radius:4px;}
        ::-webkit-scrollbar-track{background:transparent;}

        .btn{
            background:transparent;border:2px solid var(--cyan);color:var(--cyan);
            padding:10px 25px;font-family:'Orbitron',sans-serif;font-weight:bold;
            transition:.25s;position:relative;overflow:hidden;text-transform:uppercase;
            text-shadow:0 0 5px var(--cyan);letter-spacing:1px;
        }
        .btn::before{
            content:"";position:absolute;left:-120%;top:0;width:120%;height:100%;
            background:linear-gradient(120deg,transparent,rgba(255,255,255,.4),transparent);
            transform:skewX(-25deg);
        }
        .btn:hover::before{left:120%;}
        .btn:hover{
            background:var(--cyan);color:black;box-shadow:0 0 25px var(--cyan),inset 0 0 10px rgba(255,255,255,.5);
            transform:scale(1.05) translateY(-2px);text-shadow:none;
        }
        .btn:disabled{border-color:#444;color:#444;cursor:not-allowed;box-shadow:none;transform:none;text-shadow:none;}

        .input{
            width:100%;padding:10px 14px;background:rgba(0,0,0,.5);
            border:1px solid #444;color:white;font-family:'Noto Sans SC',sans-serif;
            transition:.3s;margin-bottom:10px;border-radius:4px;
        }
        .input:focus{border-color:var(--cyan);box-shadow:0 0 15px rgba(5,217,232,.3),inset 0 0 10px rgba(5,217,232,.1);}
        .hidden{display:none!important;}
        .section-title{font-family:'Orbitron';font-size:2.5rem;text-align:center;margin:60px 0 30px;color:white;text-shadow:0 0 15px var(--cyan);}

        /* ================= 2. 布局与整体背景 ================= */
        #app-container{transition:filter .5s ease-out,transform .5s ease-out;}
        body.auth-active #app-container{filter:blur(10px) brightness(.4);transform:scale(.98);pointer-events:none;}
        .bg-anim{position:fixed;inset:0;z-index:-10;background:radial-gradient(circle at 50% 0,rgba(189,0,255,.18),transparent 60%),url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%2305d9e8' fill-opacity='0.04'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");}
        #canvas-bg{position:fixed;inset:0;z-index:-5;opacity:.7;}

        /* ================= 3. 登录 / 注册 ================= */
        #auth-overlay,#profile-viewer-overlay{
            position:fixed;inset:0;z-index:20000;background:rgba(5,2,10,.82);
            display:flex;justify-content:center;align-items:center;
            backdrop-filter:blur(10px);opacity:0;pointer-events:none;transition:opacity .5s;
        }
        #auth-overlay.active,#profile-viewer-overlay.active{opacity:1;pointer-events:all;}
        .auth-box,.profile-viewer-box{
            width:420px;padding:40px;background:rgba(0,0,0,.8);
            border:2px solid var(--pink);box-shadow:0 0 60px rgba(255,42,109,.5),inset 0 0 30px rgba(255,42,109,.3);
            text-align:center;position:relative;animation:fadeIn .5s ease-out;border-radius:10px;
        }
        @keyframes fadeIn{from{opacity:0;transform:scale(.9);}to{opacity:1;transform:scale(1);}}
        .auth-title{font-family:'Orbitron',sans-serif;font-size:2rem;margin-bottom:30px;color:white;text-shadow:0 0 10px var(--cyan);}
        .auth-link{font-size:.8rem;color:#888;text-decoration:underline;margin-top:10px;display:inline-block;transition:.2s;}
        .auth-link:hover{color:var(--cyan);}
        .err-msg{color:var(--pink);margin-top:15px;font-family:'Orbitron';font-size:.8rem;min-height:20px;text-shadow:0 0 5px var(--pink);}

        /* ================= 4. 顶部导航 + 英雄区 ================= */
        nav{
            position:fixed;top:0;width:100%;height:70px;padding:0 40px;
            display:flex;justify-content:space-between;align-items:center;z-index:1000;
            background:rgba(5,1,10,.9);border-bottom:1px solid rgba(255,255,255,.1);backdrop-filter:blur(10px);
        }
        .brand{font-family:'Orbitron',sans-serif;font-weight:900;font-size:1.6rem;color:white;text-shadow:0 0 10px var(--cyan),0 0 20px var(--purple);}
        .nav-links{display:flex;align-items:center;gap:20px;}
        .nav-item{
            margin-left:10px;color:#aaa;text-decoration:none;font-family:'Orbitron';font-size:.9rem;
            transition:.3s;position:relative;padding:5px 0;letter-spacing:1px;
        }
        .nav-item:after{
            content:'';position:absolute;bottom:0;left:0;width:0;height:2px;background:var(--cyan);transition:width .3s;
        }
        .nav-item:hover{color:var(--cyan);text-shadow:0 0 8px var(--cyan);}
        .nav-item:hover:after{width:100%;}
        .user-badge{
            border:2px solid var(--gold);padding:6px 15px;color:var(--gold);
            border-radius:999px;font-family:'Orbitron';display:flex;gap:8px;align-items:center;
            transition:.3s;text-shadow:0 0 8px var(--gold);background:rgba(0,0,0,.5);
        }
        .user-badge:hover{background:rgba(255,215,0,.12);box-shadow:0 0 18px rgba(255,215,0,.4);transform:scale(1.05);}
        section{padding:120px 40px 80px;max-width:1400px;margin:0 auto;}
        .hero{min-height:100vh;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;}
        h1{
            font-family:'Orbitron',sans-serif;font-size:5.2rem;margin-bottom:20px;
            text-shadow:0 0 25px var(--pink),0 0 40px var(--purple);animation:glitch 3s infinite alternate;
        }
        @keyframes glitch{
            0%,100%{text-shadow:0 0 25px var(--pink),0 0 40px var(--purple);}
            50%{transform:skew(-.5deg);text-shadow:2px 2px 0 var(--cyan),-2px -2px 0 var(--pink);}
            51%{transform:skew(.5deg);text-shadow:-2px 2px 0 var(--cyan),2px -2px 0 var(--pink);}
        }

        /* ================= 5. 角色卡片 (NGNL 专属风格) ================= */
.char-gallery {
    display: flex;
    justify-content: center;
    gap: 35px;
    flex-wrap: wrap;
    perspective: 1500px;
    padding: 30px 0;
}

.char-card {
    width: 250px;
    height: 380px;
    position: relative;
    cursor: pointer;
    z-index: 1;
}

.char-inner {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.3, 1, 0.2, 1);
    border-radius: 14px;
    /* NGNL 标志性发光边框：粉紫青渐变 */
    box-shadow: 
        0 0 15px rgba(255, 42, 109, 0.4), /* Pink glow */
        0 0 30px rgba(5, 217, 232, 0.2);  /* Cyan glow */
}

.char-card:hover .char-inner {
    transform: rotateY(180deg);
    /* 悬停时增强光效 */
    box-shadow: 
        0 0 25px rgba(255, 42, 109, 0.7),
        0 0 50px rgba(5, 217, 232, 0.5);
}

/* 渐变边框层 (模拟边框) */
.char-inner::after {
    content: "";
    position: absolute;
    inset: -3px; /* 向外扩一点 */
    border-radius: 16px;
    background: linear-gradient(135deg, var(--pink), var(--purple), var(--cyan));
    z-index: -1;
}

.char-face {
    position: absolute;
    inset: 0;
    border-radius: 14px;
    backface-visibility: hidden;
    overflow: hidden;
    background: #fff; /* 必须是白色以融合白底图片 */
}

/* --- 正面设计 --- */
.char-front {
    display: flex;
    flex-direction: column;
}

/* 1. 图片区域 */
.char-front img {
    width: 100%;
    height: 65%;
    object-fit: contain;
    padding: 15px;
    background: #fff;
    /* 关键：给图片四周加一个内阴影，让白色背景看起来像一种发光特效，而不是简单的白块 */
    box-shadow: inset 0 0 30px rgba(255, 42, 109, 0.15); 
    transition: transform 0.4s ease;
}

.char-card:hover .char-front img {
    transform: scale(1.05);
}

/* 2. 信息区域 (重做：深紫色 + 棋盘格) */
.char-front-info {
    flex: 1; /* 占满剩余空间 */
    background: linear-gradient(180deg, #180a25 0%, #05010a 100%); /* 深紫色渐变 */
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border-top: 2px solid var(--cyan);
    z-index: 2;
    overflow: hidden;
}

/* 3. 棋盘格纹理 (NGNL 核心元素) */
.char-front-info::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image: 
        linear-gradient(45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.03) 75%, rgba(255,255,255,0.03)),
        linear-gradient(45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.03) 75%, rgba(255,255,255,0.03));
    background-size: 20px 20px;
    background-position: 0 0, 10px 10px;
    z-index: 0;
    pointer-events: none;
}

/* 4. 名字样式 */
.char-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.4rem;
    font-weight: 800;
    color: #fff;
    text-shadow: 
        2px 2px 0px var(--purple),
        -1px -1px 5px rgba(255, 255, 255, 0.5);
    margin-bottom: 6px;
    position: relative;
    z-index: 2;
    letter-spacing: 2px;
}

/* 5. 种族标签 (霓虹胶囊) */
.char-race {
    font-size: 0.7rem;
    color: var(--cyan);
    border: 1px solid var(--cyan);
    padding: 3px 12px;
    border-radius: 4px; /* 稍微方一点，更有科技感 */
    background: rgba(5, 217, 232, 0.05);
    box-shadow: 0 0 10px rgba(5, 217, 232, 0.3);
    text-transform: uppercase;
    position: relative;
    z-index: 2;
    font-family: 'Orbitron';
}

/* --- 背面设计 (保持神秘感) --- */
.char-back {
    background: #11051a; /* 深紫色 */
    transform: rotateY(180deg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    border: 2px solid var(--purple);
    box-shadow: inset 0 0 50px rgba(217, 5, 232, 0.2);
}

/* 背面背景：特图的六芒星或棋盘光效 */
.char-back::after {
    content: "♔"; /* 巨大的棋子背景 */
    position: absolute;
    font-size: 10rem;
    color: rgba(255, 255, 255, 0.03);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

.card-symbol {
    font-size: 2.5rem;
    color: var(--gold);
    width: 60px;
    height: 60px;
    border: 2px solid var(--gold);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 15px;
    background: rgba(0,0,0,0.5);
    box-shadow: 0 0 20px var(--gold);
    position: relative;
    z-index: 2;
}

.char-desc {
    font-size: 0.85rem;
    color: #e0e0e0;
    text-align: center;
    line-height: 1.6;
    position: relative;
    z-index: 2;
}
/* ===== Anime Player Layout ===== */
.anime-layout{
    display:flex;
    gap:18px;
    margin-top:10px;
}

/* 左侧：列表 */
.anime-list{
    width:260px;
    max-height:520px;
    overflow-y:auto;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(10,10,25,.9);
    padding:10px;
}
.anime-card{
    padding:8px 10px;
    border-radius:10px;
    margin-bottom:6px;
    cursor:pointer;
    transition:background .2s, transform .15s;
}
.anime-card:hover{
    background:rgba(255,255,255,.06);
    transform:translateY(-1px);
}
.anime-card.active{
    background:linear-gradient(90deg,var(--pink),var(--purple));
}
.anime-card-title{
    font-size:.9rem;
    font-weight:bold;
}
.anime-card-ep{
    font-size:.78rem;
    color:#ccc;
}

/* 右侧：播放器 & 评论 */
.anime-main{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:10px;
}
.anime-video-wrap{
    position:relative;
    width:100%;
    background:#000;
    border-radius:16px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,.12);
}
.anime-video{
    width:100%;
    max-height:420px;
    display:block;
}

/* 覆盖在视频上的弹幕层 */
#anime-danmaku-layer {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    z-index: 10;
}

/* ============= B站风格弹幕特效 ============= */

/* 弹幕通用 */
.dm-item {
    position: absolute;
    white-space: nowrap;
    will-change: transform;
    font-weight: bold;
    font-family: "SimHei", "Microsoft YaHei", sans-serif;
    /* B站风格：强描边，保证在任何背景下清晰可见 */
    text-shadow: 
        1px 1px 0 #000, 
        -1px -1px 0 #000,  
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 2px rgba(0,0,0,0.8);
    pointer-events: none;
    line-height: 1.2;
}

/* 模式 1: 滚动 (默认) */
.dm-scroll {
    right: -20%; /* 从右侧屏幕外开始 */
    animation: dm-move 10s linear forwards;
}
@keyframes dm-move {
    from { transform: translateX(0); }
    to { transform: translateX(-200vw); } /* 移动到左侧屏幕外 */
}

/* 模式 2: 顶部固定 */
.dm-top {
    left: 50%;
    transform: translateX(-50%);
    top: 20px; /* 默认起始位，JS会动态调整避免重叠 */
    animation: dm-fade-fixed 5s linear forwards;
    z-index: 20;
    border-bottom: 2px solid transparent; /* 稍微占位 */
}

/* 模式 3: 底部固定 */
.dm-bottom {
    left: 50%;
    transform: translateX(-50%);
    bottom: 40px;
    animation: dm-fade-fixed 5s linear forwards;
    z-index: 20;
}

/* 固定弹幕只需淡入淡出，不需要移动 */
@keyframes dm-fade-fixed {
    0% { opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { opacity: 0; }
}

/* 弹幕控制条样式优化 */
.anime-dm-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(0,0,0,0.6);
    padding: 6px 10px;
    border-radius: 8px;
    margin-right: 10px;
}
.dm-select {
    background: #222;
    color: white;
    border: 1px solid #444;
    padding: 4px;
    border-radius: 4px;
    font-size: 0.8rem;
}
input[type="color"] {
    width: 30px;
    height: 24px;
    border: none;
    background: transparent;
    cursor: pointer;
}

/* 工具栏 / 弹幕输入 */
.anime-toolbar{
    display:flex;
    align-items:center;
    gap:10px;
    margin-top:4px;
    font-size:.85rem;
}
.anime-dm-input{
    display:flex;
    gap:8px;
    margin-top:4px;
}

/* 评论区 */
.anime-comments{
    margin-top:6px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.08);
    padding:10px 12px;
    background:rgba(5,5,20,.9);
}
.anime-comment-list{
    max-height:220px;
    overflow-y:auto;
    margin-bottom:8px;
}
.anime-comment-card{
    padding:6px 0;
    border-bottom:1px dashed rgba(255,255,255,.1);
}
.anime-comment-header{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:.8rem;
    color:#aaa;
}
.anime-comment-body{
    font-size:.9rem;
    margin:4px 0;
}
.anime-comment-actions{
    font-size:.75rem;
    color:#888;
    display:flex;
    gap:12px;
}
.anime-comment-actions span{
    cursor:pointer;
}
.anime-comment-input{
    display:flex;
    flex-direction:column;
    gap:6px;
}
#anime-fav-btn.fav-on{
    background:linear-gradient(90deg,var(--gold),var(--pink));
    color:#000;
}


        /* ================= 6. 用户系统 MODAL + 设定为居中 ================= */
        #user-overlay.modal-layer{
            display:flex;align-items:center;justify-content:center;
        }
        .modal-layer{
            position:fixed;inset:0;z-index:9000;background:rgba(5,5,10,.96);
            display:flex;flex-direction:column;opacity:0;pointer-events:none;transition:all .5s;backdrop-filter:blur(6px);
        }
        .modal-layer.active{opacity:1;pointer-events:all;}
        .profile-ui{
            width:1000px;height:640px;margin:auto;background-color:#050713;
            background-image:radial-gradient(circle at 0 0,rgba(5,217,232,.2),transparent 55%),radial-gradient(circle at 100% 100%,rgba(217,5,232,.25),transparent 55%);
            border:1px solid var(--cyan);display:flex;border-radius:16px;overflow:hidden;box-shadow:0 0 50px rgba(5,217,232,.35);transform:scale(.98);transition:transform .5s;
        }
        #user-overlay.active .profile-ui{transform:scale(1);}
        .p-side{width:260px;background:rgba(0,0,0,.75);border-right:1px solid #222;display:flex;flex-direction:column;}
        .p-head{padding:16px 18px;border-bottom:1px solid #333;font-family:'Orbitron';color:var(--pink);display:flex;justify-content:space-between;align-items:center;}
        .f-list{flex:1;overflow-y:auto;}
        .f-item{padding:10px 16px;border-bottom:1px solid #222;display:flex;align-items:center;gap:8px;transition:.2s;position:relative;font-size:.9rem;}
        .f-item:hover,.f-item.active{background:linear-gradient(90deg,rgba(5,217,232,.25),transparent);border-right:3px solid var(--cyan);}
        .f-name{flex:1;cursor:pointer;}
        .f-status{font-size:.7rem;color:#888;}
        .f-actions{display:flex;gap:4px;}
        .f-actions .btn{padding:2px 6px;font-size:.65rem;border-width:1px;}
        .p-content{flex:1;display:flex;flex-direction:column;position:relative;background:radial-gradient(circle at 50% 0,rgba(5,217,232,.2),transparent 60%);}
        .p-tabs{height:46px;border-bottom:1px solid #333;display:flex;}
        .p-tab{flex:1;background:transparent;border:none;color:#777;font-family:'Orbitron';font-size:.75rem;letter-spacing:1px;}
        .p-tab.active{color:#fff;background:rgba(255,255,255,.05);border-bottom:2px solid var(--cyan);}
        .view{position:absolute;inset:46px 0 0;padding:24px 32px;transition:opacity .3s,transform .3s;}
        .view.hidden{opacity:0;pointer-events:none;transform:scale(.98);}
        .stat-grid{margin-top:24px;display:grid;grid-template-columns:1fr 1fr;gap:18px;}
        .stat-box{background:rgba(255,255,255,.04);padding:16px;border-radius:10px;border:1px solid #333;text-align:center;transition:.3s;}
        .stat-box:hover{box-shadow:0 0 18px rgba(5,217,232,.35);transform:translateY(-3px);}
        .exp-bar{width:100%;height:18px;background:#111;border-radius:9px;margin:8px 0;overflow:hidden;border:1px solid #444;padding:2px;}
        .exp-fill{height:100%;border-radius:7px;background:linear-gradient(90deg,var(--cyan),var(--purple));box-shadow:0 0 10px var(--cyan);transition:width .8s ease-out;}
        .exp-text{font-family:'Orbitron';color:#ccc;text-align:right;font-size:.8rem;}
        .rank-badge{
            display:inline-block;
            padding:4px 10px;
            border-radius:999px;
            font-family:'Orbitron';
            font-size:.9rem;
            letter-spacing:1px;
            border:1px solid rgba(255,255,255,.3);
            position:relative;
            overflow:hidden;
        }
        .rank-tier-C{
            box-shadow:0 0 8px rgba(5,217,232,.4);
        }
        .rank-tier-B{
            box-shadow:0 0 12px rgba(217,5,232,.7);
            animation:rankPulseB 2.5s infinite;
        }
        @keyframes rankPulseB{
            0%,100%{transform:scale(1);box-shadow:0 0 10px rgba(217,5,232,.6);}
            50%{transform:scale(1.05);box-shadow:0 0 22px rgba(5,217,232,.9);}
        }
        .rank-tier-A{
            box-shadow:0 0 18px rgba(255,255,255,.9);
        }
        .rank-tier-A::before{
            content:"";
            position:absolute;
            inset:-2px;
            border-radius:inherit;
            background:conic-gradient(from 0deg,var(--pink),var(--cyan),var(--purple),var(--pink));
            animation:rankBorderSpin 3s linear infinite;
            opacity:0.8;
            z-index:-1;
        }
        .rank-tier-A::after{
            content:"";
            position:absolute;
            inset:2px;
            border-radius:inherit;
            background:rgba(5,2,15,0.9);
            z-index:-1;
        }
        @keyframes rankBorderSpin{
            from{transform:rotate(0);}
            to{transform:rotate(360deg);}
        }
        .chat-view{display:flex;flex-direction:column;height:100%;}
        .chat-header{padding:10px 18px;border-bottom:1px solid #333;font-family:'Orbitron';font-size:1rem;color:var(--cyan);}
        .chat-box{flex:1;padding:16px 20px;overflow-y:auto;display:flex;flex-direction:column;gap:10px;}
        .msg{max-width:70%;padding:8px 12px;border-radius:14px;font-size:.85rem;line-height:1.4;position:relative;}
        .msg.me{align-self:flex-end;background:linear-gradient(45deg,var(--cyan),#00b8c5);color:black;border-bottom-right-radius:4px;}
        .msg.them{align-self:flex-start;background:#262626;border:1px solid #444;border-bottom-left-radius:4px;}
        .chat-input{padding:8px 16px;border-top:1px solid #333;display:flex;gap:8px;align-items:center;}
        /* 聊天输入框下方的表情条 */
.chat-emoji-bar{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    font-size:1.1rem;
    margin:4px 0;
}
.chat-emoji-bar span{
    cursor:pointer;
    padding:2px 6px;
}
.chat-emoji-bar span:hover{
    transform:scale(1.1);
}


        /* Settings view */
        .settings-grid{display:grid;grid-template-columns:1.2fr 1fr;gap:18px;margin-top:10px;}
        .settings-card{background:rgba(255,255,255,.04);border-radius:10px;border:1px solid #333;padding:14px 16px;}
        .settings-card h3{font-family:'Orbitron';font-size:.9rem;margin-bottom:8px;color:var(--cyan);}
        .textarea{width:100%;height:90px;background:rgba(0,0,0,.45);border:1px solid #444;color:#fff;border-radius:6px;padding:8px;font-size:.85rem;resize:vertical;}
        .settings-row{display:flex;gap:8px;margin-top:6px;align-items:center;}
        .settings-row label{font-size:.8rem;color:#aaa;min-width:80px;}

        /* Shop modal */
        #shop-layer .m-body{display:flex;flex-direction:column;padding:20px 30px;gap:20px;}
        .shop-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:18px;}
        .shop-card{
            background:rgba(4,6,20,.9);border-radius:12px;border:1px solid #333;
            padding:14px 16px;position:relative;overflow:hidden;
        }
        .shop-card::before{
            content:"";position:absolute;inset:-40%;background:conic-gradient(from 0deg,var(--cyan),var(--purple),var(--pink),var(--cyan));
            opacity:.15;filter:blur(18px);animation:spinGlow 10s linear infinite;
        }
        @keyframes spinGlow{from{transform:rotate(0);}to{transform:rotate(360deg);}}
        .shop-inner{position:relative;z-index:1;}
        .shop-tag{font-size:.7rem;color:#aaa;margin-bottom:2px;}
        .shop-name{font-family:'Orbitron';font-size:.95rem;margin-bottom:4px;}
        .shop-price{font-size:.8rem;color:var(--gold);margin-bottom:6px;}
        .shop-desc{font-size:.8rem;color:#ccc;margin-bottom:10px;min-height:32px;}
        .shop-owned{font-size:.75rem;color:var(--cyan);margin-bottom:4px;}

        /* ================= 7. NOVEL READER ================= */
        .m-head{
            height:60px;background:rgba(0,0,0,.7);border-bottom:1px solid #333;
            display:flex;justify-content:space-between;align-items:center;padding:0 30px;flex-shrink:0;
        }
        .m-title{font-family:'Orbitron';letter-spacing:2px;}
        .m-body{flex:1;display:flex;overflow:hidden;position:relative;}
        .r-left-panel{width:260px;background:rgba(0,0,0,.7);border-right:1px solid #333;display:flex;flex-direction:column;}
        .r-tabs{display:flex;border-bottom:1px solid #333;}
        .r-tab{flex:1;background:transparent;border:none;color:#888;padding:10px;font-family:'Orbitron';font-size:.8rem;}
        .r-tab.active{color:#fff;background:rgba(255,255,255,.06);border-bottom:2px solid var(--cyan);}
        .r-tab-content{flex:1;overflow-y:auto;}
        .toc-item,.bm-item{
            padding:10px 14px;border-bottom:1px solid #222;transition:.2s;font-size:.9rem;cursor:pointer;
        }
        .toc-item:hover,.bm-item:hover{background:rgba(5,217,232,.18);color:var(--cyan);}
        .toc-item small{display:block;color:#888;font-size:.7rem;margin-top:2px;}

        .r-main-panel{flex:1;display:flex;flex-direction:column;position:relative;overflow:hidden;}
        #reader-bg-canvas{
            position:absolute;inset:0;z-index:0;opacity:.7;
        }
        .r-text-area{
            position:relative;z-index:1;flex:1;overflow-y:auto;
            padding:26px 6%;font-family:'ZCOOL XiaoWei',serif;font-size:1.5rem;line-height:2.2;color:#f1f1f1;
        }
        .line{position:relative;padding-right:40px;transition:background-color .2s;}
        .line:hover{background:rgba(255,255,255,.04);}
        .comment-bubble{
            position:absolute;right:10px;top:50%;transform:translateY(-50%) scale(.8);
            width:30px;height:30px;background:rgba(255,255,255,.12);border-radius:50%;
            display:flex;align-items:center;justify-content:center;opacity:0;transition:all .25s;box-shadow:0 0 0 0 rgba(5,217,232,.4);
        }
        .line:hover .comment-bubble{opacity:1;transform:translateY(-50%) scale(1);box-shadow:0 0 12px 2px rgba(5,217,232,.55);}
        .comment-icon{font-size:1.1rem;}
        .comment-count{
            font-family:'Orbitron';font-size:.7rem;position:absolute;top:-5px;right:-5px;
            background:var(--pink);border-radius:50%;width:16px;height:16px;line-height:16px;text-align:center;box-shadow:0 0 5px var(--pink);
        }
        .r-footer{
            padding:10px 10px;background:rgba(0,0,0,.8);border-top:1px solid #333;
            display:flex;justify-content:center;align-items:center;gap:16px;z-index:2;
        }
        .r-progress{font-family:'Orbitron';color:#aaa;font-size:.85rem;}
        .r-side-r{
            position:absolute;top:0;right:0;width:380px;height:100%;background:#05050a;
            border-left:1px solid #333;transform:translateX(100%);transition:transform .35s ease-out;
            display:flex;flex-direction:column;z-index:5;
        }
        .r-side-r.open{transform:translateX(0);box-shadow:-10px 0 30px rgba(0,0,0,.7);}
        .cmt-header{
            padding:12px 16px;border-bottom:1px solid #333;font-family:'Orbitron';
            color:var(--pink);display:flex;justify-content:space-between;align-items:center;
        }
        .cmt-list{flex:1;overflow-y:auto;padding:10px;}
        .cmt-card{
            background:#151515;padding:10px 12px;margin-bottom:8px;border-radius:6px;
            border-left:2px solid transparent;transition:border-color .25s,transform .25s;
        }
        .cmt-card:hover{border-color:var(--cyan);transform:translateX(-2px);}
        .mention-link{color:var(--cyan);text-decoration:none;font-weight:bold;}
        .mention-link:hover{text-decoration:underline;}
        .cmt-user{display:flex;align-items:center;gap:6px;font-size:.85rem;}
        .mini-avatar{
    width:22px;height:22px;border-radius:50%;background:#333;
    overflow:hidden;border:1px solid rgba(255,255,255,.2);
}
.mini-avatar img{width:100%;height:100%;object-fit:cover;}

/* 基础头像框容器 */
.avatar-frame{
    border-radius:50%;
    overflow:hidden;
}

/* Elkia 金色头像框 */
.avatar-frame.frame-elkia{
    border:2px solid var(--gold);
    box-shadow:0 0 14px rgba(255,215,0,.9);
}

/* Flügel 紫色光环头像框 */
.avatar-frame.frame-flugel{
    border:2px solid #ff7bff;
    box-shadow:0 0 14px rgba(255,123,255,.9);
}

/* Warbeast 霓虹头像框 */
.avatar-frame.frame-warbeast{
    border:2px solid var(--cyan);
    box-shadow:0 0 14px rgba(5,217,232,.9);
}

/* 名称 + 称号 + 签名的统一样式 */
.user-name{font-weight:bold;cursor:pointer;}
.user-title{
    margin-left:6px;
    padding:2px 6px;
    border-radius:10px;
    font-size:.7rem;
    background:linear-gradient(90deg,var(--pink),var(--purple));
}
.user-signature{
    font-size:.75rem;
    color:#aaa;
}
/* 让头像图片铺满圆圈（保险起见，虽然你在 HTML 已经写了 inline 样式） */
#profile-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

/* 如果未来想做占位图，可以用这个，但现在先隐藏文字 */
#profile-avatar-frame.has-avatar img {
    /* 有头像的时候，只显示图片 */
    opacity: 1;
}

#profile-avatar-frame:not(.has-avatar) img {
    /* 没头像的时候，可以让图片透明，只显示你想做的背景，占位先不做就行 */
    opacity: 0;
}

        .cmt-content{margin-top:4px;white-space:pre-wrap;font-size:.85rem;}
        .cmt-actions{font-size:.78rem;color:#888;display:flex;gap:10px;margin-top:4px;}
        .cmt-actions span{cursor:pointer;}

        .cmt-input-box{padding:8px 10px;border-top:1px solid #333;z-index:10;}
        .cmt-input-box .input{margin-bottom:6px;}

        /* ================= 8. 讨论区 ================= */
        #discussion-layer .m-body{padding:16px 26px;display:flex;gap:20px;}
        .forum-left{flex:2;display:flex;flex-direction:column;height:100%;}
        .forum-list{flex:1;overflow-y:auto;margin-top:10px;}
        .post-card{
            background:rgba(0,0,0,.7);border-radius:10px;border:1px solid #333;
            padding:10px 14px;margin-bottom:10px;display:flex;gap:10px;align-items:flex-start;
            transition:.25s;
        }
        .post-card:hover{box-shadow:0 0 18px rgba(5,217,232,.35);transform:translateY(-2px);}
        .post-main{flex:1;}
        .post-header{display:flex;align-items:center;gap:6px;font-size:.85rem;}
        .post-content{margin-top:4px;font-size:.9rem;white-space:pre-wrap;}
        .post-meta{margin-top:4px;font-size:.75rem;color:#777;}
        .post-actions{margin-top:4px;font-size:.78rem;color:#888;display:flex;gap:12px;}
        .post-actions span{cursor:pointer;}
        .forum-right{flex:1;background:rgba(0,0,0,.7);border-radius:10px;border:1px solid #333;padding:12px 14px;display:flex;flex-direction:column;}
        .forum-right h3{font-family:'Orbitron';font-size:.9rem;margin-bottom:6px;color:var(--cyan);}
        .forum-right textarea{flex:1;margin:6px 0 10px;}

        /* ================= 9. 设定区：棋盘与盟约 (NGNL Style) ================= */
#codex {
    position: relative;
    z-index: 1;
}

.codex-grid {
    display: grid;
    grid-template-columns: 1fr 1.4fr;
    gap: 40px;
    align-items: stretch;
}

/* --- 通用容器 --- */
.codex-card {
    background: rgba(10, 5, 15, 0.85);
    border-radius: 16px;
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(255, 42, 109, 0.3);
    box-shadow: 
        0 0 20px rgba(255, 42, 109, 0.1),
        inset 0 0 60px rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(12px);
    display: flex;
    flex-direction: column;
}

/* 顶部扫描线保持不变 */
.codex-card::before {
    content: "";
    position: absolute;
    top: 0; left: -100%; width: 100%; height: 2px;
    background: linear-gradient(90deg, transparent, var(--cyan), transparent);
    animation: scanline 4s linear infinite;
    z-index: 10;
}
@keyframes scanline { 0% { left: -100%; } 100% { left: 100%; } }

.codex-header {
    background: linear-gradient(90deg, rgba(255, 42, 109, 0.1), transparent);
    padding: 18px 24px;
    border-bottom: 1px solid rgba(255, 42, 109, 0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* 标题字体优化 */
.codex-header h3 {
    font-family: 'Orbitron', sans-serif; /* 强制科幻字体 */
    color: #fff;
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: 3px; /* 增加字间距，提升高级感 */
    text-shadow: 0 0 10px var(--pink);
    margin: 0;
    text-transform: uppercase;
}

.codex-body {
    padding: 24px;
    flex: 1;
    position: relative;
}

/* --- 左侧：十条盟约 (字体与排版优化) --- */
.pledge-list {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 14px;
    position: relative;
    z-index: 2;
}

.pledge-item {
    display: flex;
    gap: 14px;
    padding: 12px 16px;
    border-radius: 6px;
    background: linear-gradient(90deg, rgba(255,255,255,0.02), transparent);
    border-left: 2px solid rgba(255, 42, 109, 0.3);
    transition: all 0.3s ease;
    
    /* 字体核心优化 */
    font-family: 'Noto Sans SC', sans-serif; /* 确保使用思源黑体 */
    font-weight: 300; /* 使用细体，更有未来感 */
    font-size: 0.9rem;
    line-height: 1.6;
    letter-spacing: 1px; /* 增加字间距 */
    color: rgba(255, 255, 255, 0.85);
}

.pledge-item:hover {
    background: linear-gradient(90deg, rgba(255, 42, 109, 0.1), transparent);
    border-left-color: var(--cyan);
    transform: translateX(6px);
    color: #fff;
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
}

/* 序号字体 */
.pledge-num {
    font-family: 'Orbitron', sans-serif;
    color: var(--cyan);
    font-weight: bold;
    font-size: 1rem;
    text-shadow: 0 0 5px var(--cyan);
    min-width: 25px; /* 对齐优化 */
}

/* --- 右侧：种族卡片 (字体与排版优化) --- */
.race-grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    padding: 10px;
    background-image: 
        conic-gradient(rgba(255,255,255,0.03) 90deg, transparent 90deg, transparent 180deg, rgba(255,255,255,0.03) 180deg, rgba(255,255,255,0.03) 270deg, transparent 270deg);
    background-size: 40px 40px;
}

.race-card {
    position: relative;
    aspect-ratio: 1 / 1.1;
    perspective: 1000px;
    cursor: pointer;
}

.race-inner {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); /* 更有弹性的翻转动画 */
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

.race-card:hover .race-inner {
    transform: rotateY(180deg);
    box-shadow: 0 0 20px rgba(5, 217, 232, 0.3);
}

.race-front, .race-back {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

/* 正面字体优化 */
.race-front {
    background: rgba(0, 0, 0, 0.75);
    z-index: 2;
}

.r-rank {
    position: absolute;
    top: 6px; left: 8px;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.4);
    letter-spacing: 1px;
}

.r-piece {
    font-size: 2.5rem;
    margin-bottom: 8px;
    transition: transform 0.4s;
    filter: drop-shadow(0 0 5px currentColor); /* 给棋子加辉光 */
}
.race-card:hover .r-piece {
    transform: scale(1.15);
}

.r-name-en {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.8rem;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: #fff;
    margin-bottom: 2px;
}

.r-name-cn {
    font-family: 'Noto Sans SC', sans-serif;
    font-size: 0.7rem;
    font-weight: 500; /* 中等字重，比之前更清晰 */
    color: rgba(255, 255, 255, 0.6);
    letter-spacing: 2px; /* 宽字距，提升设计感 */
}

/* 背面 (详细介绍) 字体优化 */
.race-back {
    transform: rotateY(180deg);
    background: rgba(18, 12, 24, 0.95); /* 深紫色底 */
    padding: 14px;
    text-align: justify; /* 文本两端对齐 */
    border: 1px solid var(--cyan);
}

.race-desc {
    font-family: 'Noto Sans SC', sans-serif;
    font-size: 0.75rem; /* 调小字体，适应卡片 */
    font-weight: 300; /* 细体 */
    line-height: 1.8; /* 增加行高，提升可读性 */
    color: #e0e0e0;
    letter-spacing: 0.5px;
    
    /* 滚动条隐藏但可滚动 */
    width: 100%;
    height: 100%;
    overflow-y: auto;
    scrollbar-width: none;
}
.race-desc::-webkit-scrollbar { display: none; }
/* === 各种族专属配色 (应用在 race-inner 上) === */

/* Old Deus (神灵种) */
.race-card[data-tier="god"] .race-inner {
    border-color: rgba(255, 215, 0, 0.6);
    box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.15);
}
.race-card[data-tier="god"] .r-piece { 
    color: var(--gold); 
    text-shadow: 0 0 15px var(--gold);
    animation: pulseGold 2s infinite;
}

/* High Tier (幻想/精灵/天翼/龙) */
.race-card[data-tier="high"] .race-inner {
    border-color: rgba(217, 5, 232, 0.5);
}
.race-card[data-tier="high"] .r-piece { 
    color: #e08aff; text-shadow: 0 0 10px #bf00ff; 
}
/* 特殊种族微调 */
.race-card[data-race="Flügel"] .r-piece { color: #ffb4ff; text-shadow: 0 0 15px #ff7bff; }
.race-card[data-race="Dragonia"] .r-piece { color: #ff5c5c; text-shadow: 0 0 15px #ff0000; }

/* Mid Tier (地精/森精/机凯) */
.race-card[data-tier="mid"] .race-inner {
    border-color: rgba(5, 217, 232, 0.3);
}
.race-card[data-tier="mid"] .r-piece { color: #5cffe3; text-shadow: 0 0 8px #00cea8; }

.race-card[data-race="Ex-Machina"] .race-inner { border-color: #5cff5c; }
.race-card[data-race="Ex-Machina"] .r-piece { 
    color: #5cff5c; 
    text-shadow: 0 0 10px #00ff00; 
    animation: glitchText 3s infinite;
}

/* Low Tier (兽人/吸血/海栖) */
.race-card[data-tier="low"] .race-inner {
    border-color: rgba(255, 100, 100, 0.4);
}
.race-card[data-tier="low"] .r-piece { color: #ff7aa8; text-shadow: 0 0 8px #d6004d; }

/* Imanity (人类种) */
.race-card[data-race="Imanity"] .race-inner {
    border: 1px solid #fff;
    background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(0,0,0,0.5));
    box-shadow: 0 0 15px rgba(255,255,255,0.15);
}
.race-card[data-race="Imanity"] .r-piece {
    color: #fff;
    text-shadow: 0 0 10px #fff, 0 0 20px var(--cyan);
}
/* 背面特殊颜色 */
.race-card[data-race="Imanity"] .race-back {
    color: var(--cyan);
}
@media(max-width: 1024px){
    .codex-grid { grid-template-columns: 1fr; }
    .race-grid-container { grid-template-columns: repeat(4, 1fr); }
}
@media(max-width: 600px){
    .race-grid-container { grid-template-columns: repeat(2, 1fr); }
}

/* ================= 11. 战棋游戏 (Tactics Game) ================= */
.game-top-bar {
    height: 60px; background: rgba(0,0,0,0.8); border-bottom: 1px solid #333;
    display: flex; justify-content: space-between; align-items: center; padding: 0 30px;
    font-family: 'Orbitron';
}
.game-turn-indicator {
    font-size: 1.2rem; font-weight: bold; letter-spacing: 2px;
    text-shadow: 0 0 10px currentColor; color: #fff;
}
.game-container {
    flex: 1; display: flex; overflow: hidden; height: calc(100% - 60px);
}
.game-board-wrap {
    flex: 1; display: flex; justify-content: center; align-items: center;
    background: radial-gradient(circle, #1a1a2e 0%, #05010d 100%);
    overflow: auto; perspective: 1000px;
}
.game-board {
    display: grid; gap: 4px;
    /* 8x8 board by default */
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    transform: rotateX(20deg); /* 伪3D视角 */
    transition: transform 0.5s;
    padding: 20px;
    background: rgba(255,255,255,0.02);
    box-shadow: 0 20px 50px rgba(0,0,0,0.8);
    border: 2px solid var(--cyan);
}

/* 棋盘格子 */
.tile {
    width: 60px; height: 60px;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
    position: relative;
    cursor: pointer;
    transition: all 0.2s;
}
.tile:hover { box-shadow: inset 0 0 15px rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); }

/* 移动/攻击 范围指示 */
.tile.range-move { background: rgba(5, 217, 232, 0.3); box-shadow: inset 0 0 10px var(--cyan); }
.tile.range-attack { background: rgba(255, 42, 109, 0.3); box-shadow: inset 0 0 10px var(--pink); cursor: crosshair; }

/* 棋子 (Unit) */
.unit {
    width: 80%; height: 80%; margin: 10%;
    border-radius: 50%;
    position: relative; z-index: 5;
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    display: flex; align-items: center; justify-content: center;
    font-size: 1.5rem; pointer-events: none; /* 点击穿透给格子处理 */
}
/* 阵营区分 */
.unit.team-blue { border: 2px solid var(--cyan); background: rgba(5, 217, 232, 0.2); color: var(--cyan); text-shadow: 0 0 5px var(--cyan); }
.unit.team-red { border: 2px solid var(--pink); background: rgba(255, 42, 109, 0.2); color: var(--pink); text-shadow: 0 0 5px var(--pink); }

.unit.active { transform: scale(1.2) translateY(-10px); box-shadow: 0 20px 20px rgba(0,0,0,0.6); z-index: 10; border-color: #fff; }
.unit.done { filter: grayscale(100%); opacity: 0.7; transform: scale(0.9); }

/* 血条 */
.u-hp-mini {
    position: absolute; bottom: -5px; left: 0; width: 100%; height: 4px; background: #333;
}
.u-hp-fill { height: 100%; background: #0f0; transition: width 0.3s; }

/* 右侧面板 */
.game-sidebar {
    width: 300px; background: rgba(5,5,10,0.95); border-left: 1px solid #333;
    display: flex; flex-direction: column; padding: 20px; z-index: 10;
}
.unit-status-card {
    background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border: 1px solid var(--cyan);
    margin-bottom: 20px; text-align: center; transition: opacity 0.3s;
}
.u-avatar {
    width: 60px; height: 60px; border-radius: 50%; background: #333; margin: 0 auto 10px;
    border: 2px solid #fff; font-size: 2rem; display: flex; align-items: center; justify-content: center;
}
.hp-bar-bg { width: 100%; height: 10px; background: #222; margin: 0 10px; border-radius: 5px; overflow: hidden; }
.hp-bar-fill { height: 100%; background: linear-gradient(90deg, #ff4d4d, #ff9e9e); width: 100%; transition: width 0.3s; }
.stat-row { display: flex; align-items: center; justify-content: space-between; font-size: .85rem; margin-bottom: 10px; }
.stat-grid-mini { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; font-size: .8rem; font-family: 'Orbitron'; }
.game-log-box { flex: 1; display: flex; flex-direction: column; overflow: hidden; border-top: 1px solid #333; padding-top: 10px; }
.game-log-content { flex: 1; overflow-y: auto; font-size: .8rem; color: #aaa; font-family: monospace; }
.log-entry { margin-bottom: 4px; border-left: 2px solid #444; padding-left: 6px; }
.log-dmg { color: var(--pink); }
.log-kill { color: red; font-weight: bold; }
.btn-sm { padding: 4px 10px; font-size: 0.75rem; }

/* 伤害飘字动画 */
.dmg-popup {
    position: absolute; left: 50%; top: 0; transform: translate(-50%, -50%);
    font-family: 'Orbitron'; font-weight: bold; font-size: 1.2rem; color: #ff2a6d;
    text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 20;
    animation: popup 1s forwards;
}
@keyframes popup { 0% { top: 0; opacity: 1; } 100% { top: -40px; opacity: 0; } }

        /* ================= 10. 其它 ================= */
        footer{text-align:center;padding:40px;color:#555;font-family:'Orbitron';font-size:.8rem;}
        @media(max-width:1024px){
            nav{padding:0 18px;}
            section{padding:110px 18px 60px;}
            .profile-ui{width:95%;height:640px;}
            .codex-grid{grid-template-columns:1fr;}
        }
        @media(max-width:768px){
            h1{font-size:3.4rem;}
            .char-gallery{gap:18px;}
            .char-card{width:200px;height:300px;}
            .r-left-panel{display:none;}
        }
        /* ================= 消息提醒 Toast ================= */
#toast-container {
    position: fixed;
    top: 80px; /* 避开导航栏 */
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: none; /* 让鼠标能穿透空白区域 */
}

.toast-msg {
    pointer-events: auto;
    background: rgba(5, 5, 15, 0.95);
    border: 1px solid var(--cyan);
    border-left: 4px solid var(--pink);
    padding: 12px 18px;
    border-radius: 4px;
    color: white;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.85rem;
    box-shadow: 0 0 15px rgba(5, 217, 232, 0.3);
    min-width: 250px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    animation: slideInRight 0.4s ease-out, fadeOut 0.5s ease-in 4.5s forwards;
    cursor: pointer;
}

.toast-sender { color: var(--cyan); font-weight: bold; margin-bottom: 2px; }
.toast-text { color: #ccc; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }

@keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}
@keyframes fadeOut {
    to { opacity: 0; transform: translateY(-10px); pointer-events: none; }
}
</style>
</head>
<body id="body">
<div id="cursor"></div>

<!-- ============= 1. AUTH OVERLAY ============= -->
<div id="auth-overlay">
    <div class="auth-box">
        <h2 id="auth-head" class="auth-title">SYSTEM LOGIN</h2>
        <div id="form-login">
            <input id="login-email" class="input" type="email" placeholder="EMAIL">
            <input id="login-pass" type="password" class="input" placeholder="PASSWORD">
            <button class="btn" style="width:100%" onclick="auth.login()">CONNECT</button>
            <div class="auth-link" onclick="ui.switchAuth('register')">New Player? Register</div>
        </div>
        <div id="form-register" class="hidden">
            <input id="reg-user" class="input" placeholder="USERNAME">
            <input id="reg-email" class="input" type="email" placeholder="EMAIL">
            <input id="reg-pass" type="password" class="input" placeholder="PASSWORD">
            <button id="reg-code-btn" class="btn" style="width:100%" onclick="auth.requestCode()">GET CODE</button>
            <div class="auth-link" onclick="ui.switchAuth('login')">Already a Player? Login</div>
        </div>
        <div id="form-confirm" class="hidden">
            <p style="color:#888;font-size:.8rem;margin-bottom:10px;">Code sent. (Test code: 123456)</p>
            <input id="reg-code" class="input" placeholder="VERIFICATION CODE">
            <button class="btn" style="width:100%" onclick="auth.register()">CONFIRM</button>
            <div class="auth-link" onclick="ui.switchAuth('register')">Back</div>
        </div>
        <div id="auth-msg" class="err-msg"></div>
    </div>
</div>

<!-- ============= 2. MAIN APP ============= -->
<div id="app-container">
    <div class="bg-anim"></div>
    <canvas id="canvas-bg"></canvas>

    <nav>
        <div id="toast-container"></div>
        <div class="brand">DISBOARD</div>
        <div class="nav-links">
            <a href="#hero" class="nav-item">HOME</a>
           <a href="#" class="nav-item" onclick="ui.showModal('reader-layer');reader.ensureReady();return false;">ARCHIVE</a>
           <a href="#codex" class="nav-item">CODEX</a>
           <a href="#" class="nav-item" onclick="ui.showModal('anime-layer');animePage.ensureReady();return false;">ANIME</a>
           <a href="#" class="nav-item" onclick="ui.showModal('discussion-layer');forum.init();return false;">FORUM</a>
           <a href="#" class="nav-item" onclick="ui.showModal('shop-layer');shop.init();return false;">SHOP</a>
           <a href="#" class="nav-item" onclick="ui.showModal('game-layer');chessGame.init();return false;">GAME</a>
        </div>
        <div class="user-badge" onclick="ui.showModal('user-overlay')">
            <span id="hud-username">GUEST</span>
            <span id="hud-coins">🪙 0</span>
        </div>
    </nav>

    <header id="hero" class="hero">
        <h1>NO GAME NO LIFE</h1>
        <p style="color:#aaa;letter-spacing:2px;margin-bottom:40px;">『さあ、ゲームを始めよう』</p>
        <button class="btn" onclick="ui.showModal('reader-layer');reader.ensureReady();">READ NOVEL</button>
    </header>

    <section id="players">
        <h2 class="section-title">MAIN PLAYERS</h2>
        <div class="char-gallery" id="char-grid"></div>
    </section>

    <!-- CODEX SECTION -->
    <section id="codex">
        <h2 class="section-title">DISBOARD CODEX</h2>
        
        <div class="codex-grid">
            <div class="codex-card">
                <div class="codex-bg-logo">⚖️</div>
                <div class="codex-header">
                    <h3>TEN PLEDGES</h3>
                    <div class="codex-icon">📜</div>
                </div>
                <div class="codex-body">
                    <ul class="pledge-list">
                        <li class="pledge-item"><span class="pledge-num">1.</span> <span>杀戮、战争与掠夺在这个世界一概禁止。</span></li>
                        <li class="pledge-item"><span class="pledge-num">2.</span> <span>所有的纠纷一律通过游戏解决。</span></li>
                        <li class="pledge-item"><span class="pledge-num">3.</span> <span>游戏中赌上的筹码须为双方公认对等之物。</span></li>
                        <li class="pledge-item"><span class="pledge-num">4.</span> <span>只要不违反第三条，游戏内容、赌注皆不受限制。</span></li>
                        <li class="pledge-item"><span class="pledge-num">5.</span> <span>受挑战方有权决定游戏的内容与规则。</span></li>
                        <li class="pledge-item"><span class="pledge-num">6.</span> <span>“向盟约宣誓”的赌约绝对要遵守。</span></li>
                        <li class="pledge-item"><span class="pledge-num">7.</span> <span>集团间的纠纷应指定全权代理人。</span></li>
                        <li class="pledge-item"><span class="pledge-num">8.</span> <span>游戏中若有作弊行为，一旦被败露即视为败北。</span></li>
                        <li class="pledge-item"><span class="pledge-num">9.</span> <span>以神之名宣布，以上各条皆为绝对不变的规则。</span></li>
                        <li class="pledge-item"><span class="pledge-num">10.</span><span>大家一起和平地玩吧！</span></li>
                    </ul>
                </div>
            </div>

            <div class="codex-card">
                <div class="codex-header">
                    <h3>IXSEED RANKING</h3>
                    <div class="codex-icon">♟️</div>
                </div>
                <div class="codex-body">
                    <div id="race-list-container" class="race-grid-container"></div>
                    
                    <div class="codex-footer">
                        <strong>序列设定 (Ixseed)：</strong><br>
                        十六种族是拥有知性并能使用语言的物种。位阶（Rank）基于种族对魔法的适性与运用能力排序。<br>
                        位列前6位的种族被称为“生命”，而后10位则被视为“生物”。
                    </div>
                </div>
            </div>
        </div>
    </section>

    <footer><p>DISBOARD SYSTEM v40.0 — 『It’s checkmate from move zero.』</p></footer>
</div>

<!-- ============= 3. USER PROFILE MODAL ============= -->
<div id="user-overlay" class="modal-layer">
    <div class="profile-ui">
        <div class="p-side">
            <div class="p-head"><span>SOCIAL</span><button class="btn" onclick="social.addFriend()">+</button></div>
            <div id="friend-list" class="f-list"></div>
            <div style="padding:10px;border-top:1px solid #333;">
                <button class="btn" style="width:100%;border-color:var(--pink);color:var(--pink)" onclick="auth.logout()">LOGOUT</button>
            </div>
        </div>
        <div class="p-content">
            <div class="p-tabs">
                <button id="tab-stats" class="p-tab active" onclick="ui.switchProfileTab('stats')">PROFILE</button>
                <button id="tab-chat" class="p-tab" onclick="ui.switchProfileTab('chat')">CHAT</button>
                <button id="tab-settings" class="p-tab" onclick="ui.switchProfileTab('settings')">SETTINGS</button>
            </div>
            <div id="view-stats" class="view">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div class="mini-avatar avatar-frame" style="width:56px;height:56px;border-radius:50%;overflow:hidden;border-width:2px;" id="profile-avatar-frame">
                        <img id="profile-avatar" src="" alt="avatar" style="width:100%;height:100%;object-fit:cover;">
                    </div>
                    <div>
                        <h2 id="profile-name" style="font-family:'Orbitron';font-size:1.4rem;"></h2>
                        <div id="profile-title" style="font-size:.75rem;color:var(--gold);margin-top:2px;"></div>
                        <p id="profile-bio" style="color:#aaa;margin-top:6px;min-height:36px;font-size:.85rem;"></p>
                        <div id="profile-signature" style="color:#ccc;font-size:.8rem;margin-top:4px;"></div>
                    </div>
                </div>
                <div class="stat-grid">
                    <div class="stat-box">
                        <div style="font-size:.8rem;color:#aaa;">RACE / TITLE</div>
                        <div id="profile-rank" class="rank-badge">Imanity · Novice Player</div>
                    </div>
                    <div class="stat-box">
                        <div style="font-size:.8rem;color:#aaa;">COINS</div>
                        <div id="profile-coins" style="font-size:1.8rem;">🪙 0</div>
                    </div>
                </div>
                <div style="margin-top:20px;">
                    <div class="exp-text">EXP</div>
                    <div class="exp-bar"><div id="profile-exp-fill" class="exp-fill"></div></div>
                    <div id="profile-exp-text" class="exp-text"></div>
                </div>
                <button class="btn" style="position:absolute;bottom:24px;left:50%;transform:translateX(-50%);" onclick="ui.hideAllModals()">CLOSE</button>
            </div>

            <div id="view-chat" class="view hidden">
                <div id="chat-header" class="chat-header"></div>
                <div id="chat-box" class="chat-box"></div>
                <div class="chat-input">
                    <input id="msg-input" class="input" style="text-align:left;margin:0;" placeholder="Message..." onkeydown="if(event.key==='Enter')social.sendMessage()">
                    <button class="btn" onclick="social.sendMessage()">SEND</button>
                </div>
            </div>

            <div id="view-settings" class="view hidden">
                <div class="settings-grid">
                    <div class="settings-card">
                        <h3>PROFILE TEXT</h3>
                        <label style="font-size:.8rem;color:#aaa;">Bio / 自我介绍</label>
                        <textarea id="settings-bio" class="textarea" placeholder="告诉世界你是谁。"></textarea>
                        <div class="settings-row" style="margin-top:10px;">
                            <label>Signature</label>
                            <input id="settings-signature" class="input" placeholder="个性签名（也会在讨论区显示）">
                        </div>
                        <button class="btn" style="margin-top:10px;" onclick="settings.saveProfile()">SAVE PROFILE</button>
                    </div>
                    <div class="settings-card">
                        <h3>AVATAR & NAME</h3>
<div class="settings-row">
    <label>Avatar URL</label>
    <input id="settings-avatar" class="input" placeholder="粘贴一张图片链接" />
</div>
<button class="btn" style="margin-bottom:8px;" onclick="settings.saveAvatar()">SAVE AVATAR</button>

<!-- 新增：本地上传 -->
<div class="settings-row" style="margin-top:4px;">
    <label>Upload</label>
    <input id="settings-avatar-file" type="file" accept="image/*" class="input" style="padding:6px 8px;">
</div>
<button class="btn" style="margin-bottom:8px;" onclick="settings.uploadAvatarFile()">UPLOAD FROM DEVICE</button>

<div style="border-top:1px dashed #444;margin:6px 0 8px;"></div>

                        <div class="settings-row">
                            <label>New Name</label>
                            <input id="settings-newname" class="input" placeholder="改名需要 100🪙">
                        </div>
                        <button class="btn" style="border-color:var(--gold);color:var(--gold);" onclick="settings.changeName()">CHANGE NAME (100 COINS)</button>
                        <p style="font-size:.75rem;color:#888;margin-top:4px;">改名会同步更新评论区、讨论区和好友列表中的名字。</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- ============= ANIME PLAYER ============= -->
<!-- 4. ANIME PLAYER MODAL -->
<div id="anime-layer" class="modal-layer">
    <div class="m-head">
        <span class="m-title">ANIME PLAYER</span>
        <button class="btn" style="border-color:var(--pink);color:var(--pink);" onclick="ui.hideAllModals()">EXIT</button>
    </div>

    <div class="m-body">
        <!-- 左：番剧列表；右：视频 + 弹幕 + 评论 -->
        <div class="anime-layout" style="flex:1;">

            <!-- 左边：番剧 / 选集列表 -->
            <div class="anime-list" id="anime-list"></div>

            <!-- 右边：播放器 + 弹幕 + 评论 -->
            <div class="anime-main">
                <!-- 视频 + 弹幕层 -->
                <div class="anime-video-wrap">
                    <video id="anime-video" class="anime-video" controls></video>
                    <div id="anime-danmaku-layer" class="anime-danmaku-layer"></div>
                </div>

                <!-- 工具栏：收藏、倍速、弹幕开关、连播 -->
                <div class="anime-toolbar">
                    <button id="anime-fav-btn" class="btn">☆ 收藏本集</button>

                    <label style="margin-left:10px;">
                        倍速
                        <select id="anime-speed" class="input" style="width:auto;display:inline-block;">
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1.0x</option>
                            <option value="1.5">1.5x</option>
                            <option value="2">2.0x</option>
                        </select>
                    </label>

                    <label style="margin-left:12px;">
                        <input type="checkbox" id="anime-dm-toggle" checked>
                        显示弹幕
                    </label>

                    <label style="margin-left:12px;">
                        <input type="checkbox" id="anime-autonext" checked>
                        自动连播
                    </label>

                    <!-- 当前标题显示（类似 b 站标题） -->
                    <div id="anime-current-title" style="margin-left:auto;font-size:.85rem;color:#ccc;"></div>
                </div>

                <!-- 弹幕输入 -->
                <div class="anime-dm-input" style="align-items:center;">
    <div class="anime-dm-controls">
        <select id="anime-dm-mode" class="dm-select">
            <option value="scroll">滚动</option>
            <option value="top">顶部</option>
            <option value="bottom">底部</option>
        </select>
        
        <input type="color" id="anime-dm-color" value="#ffffff" title="弹幕颜色">
    </div>

    <input id="anime-danmaku-input" class="input" style="margin-bottom:0;" placeholder="发一条弹幕～ (Enter 发送)" />
    <button class="btn" id="anime-danmaku-send" style="padding:6px 16px;">发送</button>
</div>

                <!-- 评论区 -->
                <div class="anime-comments">
                    <h3>评论</h3>
                    <div id="anime-comment-list" class="anime-comment-list"></div>
                    <div class="anime-comment-input">
                        <textarea id="anime-comment-input" class="textarea" placeholder="说点什么..."></textarea>
                        <button class="btn" id="anime-comment-send">发送评论</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 4. NOVEL READER MODAL -->
<div id="reader-layer" class="modal-layer">
    <div class="m-head">
        <span class="m-title">ARCHIVE</span>
        <button class="btn" style="border-color:var(--pink);color:var(--pink);" onclick="ui.hideAllModals()">EXIT</button>
    </div>
    <div class="m-body">
        <div class="r-left-panel">
            <div class="r-tabs">
                <button id="tab-toc" class="r-tab active" onclick="reader.switchTab('toc')">INDEX</button>
                <button id="tab-bm" class="r-tab" onclick="reader.switchTab('bm')">BOOKMARKS</button>
            </div>
            <div id="content-toc" class="r-tab-content"></div>
            <div id="content-bm" class="r-tab-content hidden"></div>
        </div>
        <div class="r-main-panel">
            <canvas id="reader-bg-canvas"></canvas>
            <div id="reader-text-area" class="r-text-area">
                <p style="text-align:center;color:#888;margin-top:50px;">Loading novel...</p>
            </div>
            <div class="r-footer">
                <button class="btn" onclick="reader.goToPage(state.novel.currentPage - 1)">PREV</button>
                <span id="reader-progress" class="r-progress">0 / 0</span>
                <button class="btn" onclick="reader.goToPage(state.novel.currentPage + 1)">NEXT</button>
                <button class="btn" style="border-color:var(--gold);color:var(--gold);" onclick="reader.addBookmark()">BOOKMARK</button>
            </div>
        </div>
        <div id="reader-comment-sidebar" class="r-side-r">
            <div class="cmt-header">
                <span id="cmt-header-title">COMMENTS</span>
                <button onclick="reader.closeCommentSidebar()" style="background:none;border:none;color:white;font-size:1.2rem;">×</button>
            </div>
            <div id="cmt-list" class="cmt-list"></div>
            <div class="cmt-input-box">
                <textarea id="cmt-input" class="input" rows="3" placeholder="Add a comment..."></textarea>
                <button class="btn" style="width:100%;margin-top:4px;" onclick="reader.postComment()">POST</button>
            </div>
        </div>
    </div>
</div>

<!-- 5. OTHER PROFILE VIEWER -->
<div id="profile-viewer-overlay" class="modal-layer">
    <div class="profile-viewer-box">
        <div id="profile-viewer-content"></div>
        <button class="btn" style="margin-top:20px;" onclick="document.getElementById('profile-viewer-overlay').classList.remove('active')">CLOSE</button>
    </div>
</div>

<!-- 6. DISCUSSION MODAL -->
<div id="discussion-layer" class="modal-layer">
    <div class="m-head">
        <span class="m-title">FORUM</span>
        <button class="btn" style="border-color:var(--pink);color:var(--pink);" onclick="ui.hideAllModals()">CLOSE</button>
    </div>
    <div class="m-body">
        <div class="forum-left">
            <h3 style="font-family:'Orbitron';font-size:1rem;">LATEST THREADS</h3>
            <div id="forum-list" class="forum-list"></div>
        </div>
        <div class="forum-right">
            <h3>NEW POST</h3>
            <textarea id="forum-input" class="textarea" placeholder="在这里输入你的想法，支持 @用户名。"></textarea>
            <button class="btn" onclick="forum.post()">POST</button>
        </div>
    </div>
</div>

<!-- 7. SHOP MODAL -->
<div id="shop-layer" class="modal-layer">
    <div class="m-head">
        <span class="m-title">NGNL SHOP</span>
        <button class="btn" style="border-color:var(--pink);color:var(--pink);" onclick="ui.hideAllModals()">CLOSE</button>
    </div>
    <div class="m-body">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="font-family:'Orbitron';font-size:.9rem;color:#ccc;">
                Purchase avatar frames, titles and signatures that will appear everywhere.
            </div>
            <div style="font-family:'Orbitron';color:var(--gold);">Balance: <span id="shop-coins">0</span> 🪙</div>
        </div>
        <div id="shop-grid" class="shop-grid"></div>
    </div>
</div>

<!-- 8. GAME MODAL -->
<div id="game-layer" class="modal-layer">
    <div class="m-head">
        <span class="m-title">THE GREAT WAR - TACTICS</span>
        <button class="btn" style="border-color:var(--pink);color:var(--pink);" onclick="ui.hideAllModals()">SURRENDER</button>
    </div>
    <div class="m-body" style="padding:0;display:flex;flex-direction:column;">
        <div class="game-top-bar">
            <div class="game-score">
                <span style="color:var(--cyan)">BLUE</span> vs <span style="color:var(--pink)">RED</span>
            </div>
            
            <div id="pve-difficulty-selector" style="display:none;">
                <span style="font-size:0.8rem;color:#aaa;">AI LEVEL: </span>
                <select id="game-difficulty" class="input" style="width:auto;display:inline-block;margin:0;padding:2px 8px;font-size:0.8rem;">
                    <option value="easy">EASY (Steph)</option>
                    <option value="normal" selected>NORMAL (Jibril)</option>
                    <option value="hard">HARD (Shiro)</option>
                    <option value="lunatic">LUNATIC (Tet)</option>
                </select>
            </div>

            <div class="game-turn-indicator" id="game-turn-text">WAITING...</div>

            <div class="game-controls">
                <button class="btn btn-sm" onclick="chessGame.startGame('pve')">VS CPU</button>
                <button class="btn btn-sm" onclick="chessGame.startGame('pvp')">VS PLAYER</button>
            </div>
        </div>

        <div class="game-container">
            <div class="game-board-wrap">
                <div id="game-board" class="game-board"></div>
            </div>

            <div class="game-sidebar">
                <div class="unit-status-card" id="unit-info-panel" style="opacity:0;">
                    <div class="u-avatar" id="u-avatar"></div>
                    <h3 id="u-name">NAME</h3>
                    <div id="u-race" style="color:#aaa;font-size:.8rem;margin-bottom:10px;">RACE</div>
                    
                    <div class="stat-row">
                        <span>HP</span>
                        <div class="hp-bar-bg"><div id="u-hp-bar" class="hp-bar-fill"></div></div>
                        <span id="u-hp-text">0/0</span>
                    </div>
                    <div class="stat-grid-mini">
                        <div>ATK: <span id="u-atk" style="color:var(--pink)">0</span></div>
                        <div>RNG: <span id="u-rng" style="color:var(--gold)">0</span></div>
                        <div>MOV: <span id="u-mov" style="color:var(--cyan)">0</span></div>
                    </div>
                    <div id="u-desc" style="margin-top:10px;font-size:.8rem;color:#888;line-height:1.4;"></div>
                    <button id="btn-skill" class="btn btn-sm" style="width:100%;margin-top:8px;border-color:var(--gold);color:var(--gold);" onclick="chessGame.useSkill()">SKILL</button>
                </div>

                <div class="game-log-box">
                    <h4>BATTLE LOG</h4>
                    <div id="game-log" class="game-log-content"></div>
                </div>
                
                <button id="btn-end-turn" class="btn" style="width:100%;margin-top:auto;" onclick="chessGame.endTurn()">END TURN</button>
            </div>
        </div>
        <div id="game-result-overlay" style="position:absolute;inset:0;background:rgba(5,5,10,0.98);display:flex;flex-direction:column;z-index:100;opacity:0;pointer-events:none;transition:opacity 0.5s;padding:40px;">
            <div style="text-align:center;margin-bottom:20px;">
                <h1 id="game-result-title" style="font-size:3.5rem;text-shadow:0 0 30px currentColor;margin-bottom:10px;">VICTORY</h1>
                <p id="game-result-desc" style="color:#aaa;font-family:'Orbitron';">BATTLE STATISTICS</p>
            </div>
            
            <div style="flex:1;overflow-y:auto;border:1px solid #333;background:rgba(0,0,0,0.5);border-radius:8px;padding:20px;">
                <table style="width:100%;border-collapse:collapse;color:#ddd;font-size:0.9rem;">
                    <thead>
                        <tr style="border-bottom:2px solid #444;color:var(--cyan);font-family:'Orbitron';">
                            <th style="padding:10px;text-align:left;">UNIT</th>
                            <th style="padding:10px;">DMG DEALT</th>
                            <th style="padding:10px;">HEALING</th>
                            <th style="padding:10px;">DMG TAKEN</th>
                            <th style="padding:10px;">STATUS</th>
                        </tr>
                    </thead>
                    <tbody id="game-result-tbody">
                        </tbody>
                </table>
            </div>

            <div style="margin-top:20px;text-align:center;">
                <button class="btn" onclick="document.getElementById('game-result-overlay').style.opacity=0;document.getElementById('game-result-overlay').style.pointerEvents='none';">CLOSE & RETURN</button>
            </div>
        </div>
    </div>
</div>

<script>
/* ==========================================================
   NGNL SYSTEM FRONTEND v4.2  (匹配后端：种族 / 称号 / expToNext)
   ========================================================== */

const API_URL = "https://script.google.com/macros/s/AKfycbxJBrAx1_jzwNCO6kCSVyJsNANGE4ibdXy5SXva_p54B4Zot8OaJeCm3PdQsIVhdU4v/exec";

/* --- 商店物品样式映射：用于显示头像框 / 称号 / 签名文本 --- */
const SHOP_STYLES = {
    frame_elkia:   { class: "frame-elkia" },
    frame_flugel:  { class: "frame-flugel" },
    frame_warbeast:{ class: "frame-warbeast" },

    title_blank:   { label: "『　』" },
    title_king:    { label: "KING OF GAMES" },
    title_hardcore:{ label: "HARDCORE GAMER" },

    sig_ciallo:    { label: "Ciallo～(≧▽≦)～" },
    sig_blank:     { label: "We are 『　』" }
};
/* --- 你的番剧 / 电影清单（先写死在前端） --- */
const ANIME_DATA = [
    {
        id: "ngnl_s1",
        title: "NO GAME NO LIFE 第1季",
        type: "series",
        cover: "ngnl_s1_cover.jpg", // 没有就留空字符串
        episodes: [
            { no: 1,  title: "第1话 外行人（Beginner）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/01-%E7%AC%AC1%E8%AF%9D%20%E5%A4%96%E8%A1%8C%E4%BA%BA%EF%BC%88Beginner%EF%BC%89.mp4" },
            { no: 2,  title: "第2话 挑战者（Challenger）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/02-%E7%AC%AC2%E8%AF%9D%20%E6%8C%91%E6%88%98%E8%80%85%EF%BC%88Challenger%EF%BC%89.mp4" },
            { no: 3,  title: "第3话 熟练者（Expert）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/03-%E7%AC%AC3%E8%AF%9D%20%E7%86%9F%E7%BB%83%E8%80%85%EF%BC%88Expert%EF%BC%89.mp4" },
            { no: 4,  title: "第4话 国王（Grand Master）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/05-%E7%AC%AC5%E8%AF%9D%20%E5%B8%83%E5%B1%80%EF%BC%88Weak%20Square%EF%BC%89.mp4" },
            { no: 5,  title: "第5话 布局（Weak Square）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/05-%E7%AC%AC5%E8%AF%9D%20%E5%B8%83%E5%B1%80%EF%BC%88Weak%20Square%EF%BC%89.mp4" },
            { no: 6,  title: "第6话 一步（Interesting）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/06-%E7%AC%AC6%E8%AF%9D%20%E4%B8%80%E6%AD%A5%EF%BC%88Interesting%EF%BC%89.mp4" },
            { no: 7,  title: "第7话 弃子（Sacrifice）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/07-%E7%AC%AC7%E8%AF%9D%20%E5%BC%83%E5%AD%90%EF%BC%88Sacrifice%EF%BC%89.mp4" },
            { no: 8,  title: "第8话 起死回生（Fake End）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/08-%E7%AC%AC8%E8%AF%9D%20%E8%B5%B7%E6%AD%BB%E5%9B%9E%E7%94%9F%EF%BC%88Fake%20End%EF%BC%89.mp4" },
            { no: 9,  title: "第9话 分离法（Sky Walk）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/09-%E7%AC%AC9%E8%AF%9D%20%E5%88%86%E7%A6%BB%E6%B3%95%EF%BC%88Sky%20Walk%EF%BC%89.mp4" },
            { no: 10, title: "第10话 指向法（Blue Rose）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/10-%E7%AC%AC10%E8%AF%9D%20%E6%8C%87%E5%90%91%E6%B3%95%EF%BC%88Blue%20Rose%EF%BC%89.mp4" },
            { no: 11, title: "第11话 诱导法（Killing Giant）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/11-%E7%AC%AC11%E8%AF%9D%20%E8%AF%B1%E5%AF%BC%E6%B3%95%EF%BC%88Killing%20Giant%EF%BC%89.mp4" },
            { no: 12, title: "第12话 收束法（Rule Number 10）", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8D%83%E5%A4%8F%E5%AD%97%E5%B9%95%E7%BB%84.%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E4%BA%BA%E7%94%9F%EF%BC%89No%20Game%20No%20Life.12%E9%9B%86%E5%85%A8%2B6OVA.2014.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97/12-%E7%AC%AC12%E8%AF%9D%20%E6%94%B6%E6%9D%9F%E6%B3%95%EF%BC%88Rule%20Number%2010%EF%BC%89.mp4" }
        ]
    },
    {
        id: "ngnl_movie",
        title: "NO GAME NO LIFE ZERO 剧场版",
        type: "movie",
        cover: "ngnl_movie_cover.jpg",
        episodes: [
            { no: 1, title: "剧场版", url: "https://pub-84ce65c99e20496ea23047b3588e9496.r2.dev/NGNL_S1/%E5%8A%A8%E6%BC%AB%E5%9B%BD%E5%AD%97%E5%B9%95%E7%BB%84.%E5%89%A7%E5%9C%BA%E7%89%88%20%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%20%E9%9B%B6.2017.BD.1080p.%E6%97%A5%E8%AF%AD%E4%B8%AD%E5%AD%97.mp4" }
        ]
    }
];

const state = {
    user:{
        name:"Guest",
        rank:16,
        exp:0,
        expToNext:100,
        race:"",
        rankTitle:"",
        coins:0,
        bio:"",
        avatar:"",
        frameKey:"",
        titleKey:"",
        sigKey:""
    },
    isLoggedIn:false,
    activeChat:null,
    novel:{
        lines:[],
        comments:{},
        activeCommentLine:-1,
        toc:[],
        bookmarks:[],
        linesPerPage:24,
        pages:[],
        currentPage:0,
        totalPages:0,
        initialized:false
    },
// ⭐ 新增：动漫播放相关状态
    anime:{
        currentAnimeId:null,
        currentEpisode:null,
        danmakuTimer:null,
        favorites:[]
    }
};

/* 把后端 profile 对象同步到前端 state 的统一函数 */
function applyProfileFromServer(p){
    if(!p) return;

    // ✅ 兼容两种返回：{status, username, ...} 或 {status, profile:{...}}
    if (p.profile) p = p.profile;

    state.user.name       = p.username;
    state.user.rank       = p.rank || 16;
    // 使用后端返回的 rankRace (兼容旧的 p.race)
    state.user.race       = p.rankRace || p.race || "";
    state.user.rankTitle  = p.rankTitle || "";
    state.user.exp        = p.exp  || 0;
    state.user.expToNext  = p.expToNext || 100;
    state.user.coins      = p.coins|| 0;
    state.user.bio        = p.bio  || "";
    state.user.avatar     = p.avatar || p.avatarUrl || "";
    state.user.frameKey   = p.frameKey || "";
    state.user.titleKey   = p.titleKey || "";
    state.user.sigKey     = p.sigKey   || "";

    sessionStorage.setItem('ngnlUser',JSON.stringify(state.user));
    ui.updateHUD();
    ui.updateProfileView();

    // ⭐ 登录成功 / 刷新 profile 时，同步一下收藏
    if (typeof animePage !== 'undefined' && animePage.refreshFavorites) {
        animePage.refreshFavorites();
    }
    // ⭐ 启动消息监听
    if (social && social.startPolling) {
        social.startPolling();
    }
}

async function apiRequest(payload){
    if(!API_URL.startsWith('https')){
        const errorTarget=document.getElementById('auth-msg');
        if(errorTarget && !state.isLoggedIn){
            errorTarget.innerText="API URL is not configured.";
        }
        console.error("API URL is not configured.");
        return {status:'error',message:'API URL not configured.'};
    }
    if(state.isLoggedIn){
        payload.username=state.user.name;   // 发送当前用户名给后端
    }
    try{
        const response=await fetch(API_URL,{
            method:'POST',
            mode:'cors',
            cache:'no-cache',
            headers:{'Content-Type':'text/plain;charset=utf-8'},
            body:JSON.stringify(payload),
            redirect:'follow'
        });
        return await response.json();
    }catch(e){
        console.error("API Error:",e);
        return {status:'error',message:'Network or server error.'};
    }
}

/* ================= UI & 用户样式渲染 =================== */

const ui={
    elements:{
        authOverlay:document.getElementById('auth-overlay'),
        body:document.getElementById('body'),
        authMsg:document.getElementById('auth-msg'),
        hudUsername:document.getElementById('hud-username'),
        hudCoins:document.getElementById('hud-coins'),
    },

    showModal(id){
        if(!state.isLoggedIn && !['auth-overlay','profile-viewer-overlay'].includes(id)){
            alert("Please log in to access this feature.");
            this.elements.body.classList.add('auth-active');
            this.elements.authOverlay.classList.add('active');
            return;
        }
        this.hideAllModals();
        const m=document.getElementById(id);
        if(m) m.classList.add('active');
        if(id==='user-overlay') social.init();
    },
    hideAllModals(){
        document.querySelectorAll('.modal-layer').forEach(m=>m.classList.remove('active'));
    },

    switchAuth(view){
        ['login','register','confirm'].forEach(id=>document.getElementById('form-'+id).classList.add('hidden'));
        document.getElementById('form-'+view).classList.remove('hidden');
        document.getElementById('auth-head').innerText=view==='login'?'SYSTEM LOGIN':'PLAYER REGISTRATION';
        this.elements.authMsg.innerText='';
    },
    showAuthError(msg){this.elements.authMsg.innerText=msg;},

    updateHUD(){
        this.elements.hudUsername.innerText=state.user.name.toUpperCase();
        this.elements.hudCoins.innerText=`🪙 ${state.user.coins}`;
        const shopCoins=document.getElementById('shop-coins');
        if(shopCoins) shopCoins.innerText=state.user.coins;
    },

    updateProfileView(){
        const titleLabel = SHOP_STYLES[state.user.titleKey]?.label || "";
        const sigLabel   = SHOP_STYLES[state.user.sigKey]?.label   || "";

        document.getElementById('profile-name').innerText=state.user.name;
        document.getElementById('profile-coins').innerText=`🪙 ${state.user.coins}`;
        document.getElementById('profile-bio').innerText=state.user.bio||"This player is lazy.";
        document.getElementById('profile-signature').innerText = sigLabel || "";
        document.getElementById('profile-title').innerText = titleLabel || "";

        // ====== RANK 显示：种族 + 称号 ======
        const rankBox = document.getElementById('profile-rank');
        const race    = state.user.race || "Imanity";
        const rTitle  = state.user.rankTitle || ("Rank " + state.user.rank);
        rankBox.textContent = `${race} · ${rTitle}`;

        // 根据 rank 设置不同炫酷程度
        rankBox.classList.remove('rank-tier-C','rank-tier-B','rank-tier-A');
        if(state.user.rank <= 4){
            rankBox.classList.add('rank-tier-A'); // 顶级：旧神/龙/天翼
        }else if(state.user.rank <= 8){
            rankBox.classList.add('rank-tier-B'); // 中层种
        }else{
            rankBox.classList.add('rank-tier-C'); // 新手、人类阶段
        }

        // ====== 经验条：使用 expToNext 动态需求 ======
        const need   = state.user.expToNext || 100;
        const expNow = state.user.exp || 0;
        const expFill=document.getElementById('profile-exp-fill');

        if(state.user.rank === 1){
            expFill.style.width = "100%";
            document.getElementById('profile-exp-text').innerText = "MAX (Old Deus)";
        }else{
            const percent = Math.max(0, Math.min(100, Math.round(expNow / need * 100)));
            expFill.style.width = percent + "%";
            document.getElementById('profile-exp-text').innerText = `${expNow} / ${need}`;
        }

        // 头像 / 框
const avImg = document.getElementById('profile-avatar');
const frameEl = document.getElementById('profile-avatar-frame');

// 设置头像地址
avImg.src = state.user.avatar || "sora.png";

// 根据有没有头像，给外框加 / 去掉 has-avatar
if (state.user.avatar) {
    frameEl.classList.add('has-avatar');
} else {
    frameEl.classList.remove('has-avatar');
}

// 头像框样式
frameEl.classList.remove('frame-elkia','frame-flugel','frame-warbeast');
const fk = state.user.frameKey;
if (fk && SHOP_STYLES[fk] && SHOP_STYLES[fk].class) {
    frameEl.classList.add(SHOP_STYLES[fk].class);
}


        document.getElementById('settings-bio').value=state.user.bio||"";
        document.getElementById('settings-avatar').value=state.user.avatar||"";
    },

    /* 任何地方显示头像框/称号/签名都用这个统一渲染 */
    renderUserStyle(src){
        const name = src.user || state.user.name;
        const avatar = src.avatar || src.avatarUrl || "";
        const frameKey = src.frameKey || "";
        const titleKey = src.titleKey || "";
        const sigKey   = src.sigKey || "";

        const frameClass = frameKey && SHOP_STYLES[frameKey]?.class ? SHOP_STYLES[frameKey].class : "";
        const titleLabel = titleKey && SHOP_STYLES[titleKey]?.label ? SHOP_STYLES[titleKey].label : "";
        const sigLabel   = sigKey && SHOP_STYLES[sigKey]?.label ? SHOP_STYLES[sigKey].label : "";

        const avatarHTML = `
            <div class="mini-avatar avatar-frame ${frameClass}">
                ${avatar ? `<img src="${avatar}" alt="">` : ""}
            </div>`;

        const nameHTML = `
            <span class="user-name" onclick="ui.showOtherUserProfile('${name}')">${name}</span>
            ${titleLabel ? `<span class="user-title">${titleLabel}</span>` : ""}`;

        const subHTML = sigLabel ? `<span class="user-signature">${sigLabel}</span>` : "";

        return { avatarHTML, nameHTML, subHTML };
    },

    showOtherUserProfile(username){
        if(username===state.user.name){
            ui.showModal('user-overlay');
            return;
        }
        const container=document.getElementById('profile-viewer-content');
        container.innerHTML=`<p>Loading ${username}'s profile...</p>`;
        document.getElementById('profile-viewer-overlay').classList.add('active');
        apiRequest({action:'get_profile',target_user:username}).then(res=>{
            if(res.status==='success'){
                const p=res.profile;
                const style = ui.renderUserStyle({
                    user:p.username,
                    avatar:p.avatar,
                    frameKey:p.frameKey,
                    titleKey:p.titleKey,
                    sigKey:p.sigKey
                });

                const race = p.rankRace || "Imanity";
                const rTitle = p.rankTitle || ("Rank " + p.rank);
                const need = p.expToNext || 0;
                const expNow = p.exp || 0;

                let badgeClass = "rank-badge ";
                if(p.rank <= 4) badgeClass += "rank-tier-A";
                else if(p.rank <= 8) badgeClass += "rank-tier-B";
                else badgeClass += "rank-tier-C";

                let expText, percent;
                if(p.rank === 1){
                    expText = "MAX (Old Deus)";
                    percent = 100;
                }else{
                    const n = need || 1;
                    percent = Math.max(0, Math.min(100, Math.round(expNow / n * 100)));
                    expText = `${expNow} / ${n}`;
                }

                container.innerHTML=`
                    <div style="display:flex;align-items:center;gap:14px;">
                        ${style.avatarHTML}
                        <div>
                            <div>${style.nameHTML}</div>
                            <div style="margin-top:4px;">${style.subHTML || ""}</div>
                            <div style="color:#aaa;font-size:.85rem;margin-top:6px;">${p.bio||""}</div>
                        </div>
                    </div>
                    <div class="stat-grid" style="margin-top:20px;grid-template-columns:1fr 1fr;gap:15px;">
                        <div class="stat-box">
                            <div style="font-size:.8rem;color:#aaa;">RACE / TITLE</div>
                            <div class="${badgeClass}">${race} · ${rTitle}</div>
                        </div>
                        <div class="stat-box">
                            <div style="font-size:.8rem;color:#aaa;">COINS</div>
                            <div style="font-size:1.5rem;">🪙 ${p.coins}</div>
                        </div>
                    </div>
                    <div style="margin-top:18px;">
                        <div class="exp-text">EXP</div>
                        <div class="exp-bar">
                            <div class="exp-fill" style="width:${percent}%;"></div>
                        </div>
                        <div class="exp-text">${expText}</div>
                    </div>`;
            }else{
                container.innerHTML=`<p style="color:var(--pink);">${res.message}</p>`;
            }
        });
    },

    switchProfileTab(tab){
        ['stats','chat','settings'].forEach(t=>{
            document.getElementById('view-'+t).classList.add('hidden');
            document.getElementById('tab-'+t).classList.remove('active');
        });
        document.getElementById('view-'+tab).classList.remove('hidden');
        document.getElementById('tab-'+tab).classList.add('active');
    }
};

/* ================== 认证 ================== */

const auth = {
    tempRegData:{},

    async login(){
        const email = document.getElementById('login-email').value.trim();
        const password = document.getElementById('login-pass').value;

        if(!email || !password){
            return ui.showAuthError("Email and password are required.");
        }

        ui.showAuthError("Connecting...");

        const res = await apiRequest({ action:'login', email, password });

        if(res.status === 'success'){
            // ⬇️ login 直接返回的就是 profile 字段集合（没有 res.profile 这一层）
            applyProfileFromServer(res);

            state.isLoggedIn = true;
            ui.elements.authOverlay.classList.remove('active');
            ui.elements.body.classList.remove('auth-active');
            ui.showAuthError("");

            // ⭐ 登录成功后再拉一遍收藏
        anime.refreshFavorites();
        }else{
            ui.showAuthError(res.message || "Login failed.");
        }
    },
   async requestCode(){
        const user=document.getElementById('reg-user').value.trim();
        const email=document.getElementById('reg-email').value.trim();
        const pass=document.getElementById('reg-pass').value;
        if(!user||!email||!pass) return ui.showAuthError("All fields are required.");
        const btn=document.getElementById('reg-code-btn');
        btn.disabled=true;btn.innerText="REQUESTING...";
        ui.showAuthError("Requesting code...");
        const res=await apiRequest({action:'request_code',email});
        btn.disabled=false;btn.innerText="GET CODE";
        if(res.status==='success'){
            this.tempRegData={user,email,pass};
            ui.switchAuth('confirm');
            alert(res.message);
        }else ui.showAuthError(res.message);
    },
    async register(){
        const code=document.getElementById('reg-code').value.trim();
        if(!code) return ui.showAuthError("Verification code is required.");
        ui.showAuthError("Registering...");
        const payload={
            action:'register',
            username:this.tempRegData.user,
            email:this.tempRegData.email,
            password:this.tempRegData.pass,
            code
        };
        const res=await apiRequest(payload);
        if(res.status==='success'){
            alert("Registration successful! Please log in.");
            ui.switchAuth('login');
        }else ui.showAuthError(res.message);
    },
    logout(){
        if(confirm("Are you sure you want to log out?")){
            sessionStorage.removeItem('ngnlUser');
            window.location.reload();
        }
    }
};

/* ================== 社交 & 好友系统 (含消息轮询) ================== */

const social = {
    pollingTimer: null,
    lastCheckTime: Date.now(), // 记录上次检查时间

    init() {
        this.loadFriends();
        // 如果已经登录，开始轮询消息
        if (state.isLoggedIn) {
            this.startPolling();
        }
        ui.updateProfileView();
        ui.switchProfileTab('stats');
    },

    // --- 轮询核心逻辑 ---
    startPolling() {
        if (this.pollingTimer) clearInterval(this.pollingTimer);
        this.lastCheckTime = Date.now(); // 重置时间，避免把旧消息弹出来
        
        // 每 10 秒检查一次 (可根据需要调整，太快容易触发 Google 限制)
        this.pollingTimer = setInterval(() => {
            this.checkNotifications();
        }, 10000);
    },

    stopPolling() {
        if (this.pollingTimer) clearInterval(this.pollingTimer);
        this.pollingTimer = null;
    },

    async checkNotifications() {
        if (!state.isLoggedIn) return;

        // 发送上次检查的时间戳
        const res = await apiRequest({
            action: 'check_notifications',
            last_time: this.lastCheckTime
        });

        if (res.status === 'success' && res.data && res.data.length > 0) {
            // 更新最后检查时间
            if (res.server_time) this.lastCheckTime = res.server_time;
            else this.lastCheckTime = Date.now();

            // 处理每一条新消息
            res.data.forEach(msg => {
                this.handleNewMessage(msg);
            });
        }
    },

    handleNewMessage(msg) {
        // 情况 1: 如果当前正打开着发送者的聊天窗口 -> 直接上屏
        if (state.activeChat === msg.sender && !document.getElementById('view-chat').classList.contains('hidden')) {
            const box = document.getElementById('chat-box');
            // 避免重复 (简单的防重检查)
            const lastMsg = box.lastElementChild;
            if (!lastMsg || lastMsg.innerText !== msg.content) {
                box.innerHTML += `<div class="msg them">${msg.content}</div>`;
                box.scrollTop = box.scrollHeight;
            }
        } 
        // 情况 2: 其他情况 -> 弹窗提醒
        else {
            this.showToast(msg.sender, msg.content);
            // 这里也可以给头像加个红点 (可选)
        }
    },

    showToast(sender, content) {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div');
        el.className = 'toast-msg';
        el.innerHTML = `
            <div>
                <div class="toast-sender">✉️ ${sender}</div>
                <div class="toast-text">${content}</div>
            </div>
        `;
        // 点击弹窗直接打开聊天
        el.onclick = () => {
            ui.showModal('user-overlay');
            this.startChat(sender, { currentTarget: null }); // 模拟点击
            el.remove();
        };
        // 动画结束后自动移除 DOM
        el.addEventListener('animationend', (e) => {
            if (e.animationName === 'fadeOut') el.remove();
        });
        container.appendChild(el);
    },

    // --- 原有功能保持不变 ---

    async loadFriends() {
        const list = document.getElementById('friend-list');
        list.innerHTML = `<div class="f-item">Loading friends...</div>`;
        const res = await apiRequest({ action: 'get_friends' });
        let html = `<div class="f-item active" onclick="social.showMyStats(event)"><span class="f-name">MY PROFILE</span></div>`;
        if (res.status === 'success' && res.data) {
            res.data.forEach(f => {
                html += `<div class="f-item" data-name="${f.name}">
                    <span class="f-name" onclick="social.startChat('${f.name}',event)">${f.name}</span>
                    ${social.getFriendStatusUI(f)}
                </div>`;
            });
        }
        list.innerHTML = html;
    },
    getFriendStatusUI(friend) {
        if (friend.status === 'Accepted') return `<span class="f-status" style="color:var(--cyan)">FRIEND</span>`;
        if (friend.status === 'Sent') return `<span class="f-status">SENT</span>`;
        if (friend.status === 'Received') {
            return `<div class="f-actions">
                <button class="btn" onclick="social.handleFriendRequest('${friend.name}','Accepted')">✓</button>
                <button class="btn" style="border-color:var(--pink);color:var(--pink)" onclick="social.handleFriendRequest('${friend.name}','Declined')">×</button>
            </div>`;
        }
        return '';
    },
    async handleFriendRequest(target, status) {
        const res = await apiRequest({ action: 'update_friend_status', target_user: target, new_status: status });
        alert(res.message);
        if (res.status === 'success') this.loadFriends();
    },
    showMyStats(e) {
        ui.switchProfileTab('stats');
        document.querySelectorAll('#friend-list .f-item').forEach(el => el.classList.remove('active'));
        if (e && e.currentTarget) e.currentTarget.classList.add('active');
        state.activeChat = null; // 清除当前聊天对象
    },
    async addFriend() {
        const name = prompt("Enter the player's name to send a friend request:");
        if (name && name.trim()) {
            const res = await apiRequest({ action: 'add_friend', target_user: name.trim() });
            alert(res.message);
            if (res.status === 'success') this.loadFriends();
        }
    },
    startChat(target, e) {
        state.activeChat = target;
        ui.switchProfileTab('chat');
        document.getElementById('chat-header').innerText = `Chat with ${target}`;
        
        // UI 选中状态更新
        document.querySelectorAll('#friend-list .f-item').forEach(el => el.classList.remove('active'));
        // 如果是从弹窗调用的，可能没有 event，需要手动查找 DOM
        if (e && e.currentTarget) {
            e.currentTarget.closest('.f-item').classList.add('active');
        } else {
            const item = document.querySelector(`.f-item[data-name="${target}"]`);
            if (item) item.classList.add('active');
        }
        
        this.loadMessages();
    },
    async loadMessages() {
        if (!state.activeChat) return;
        const box = document.getElementById('chat-box');
        box.innerHTML = "Loading messages...";
        const res = await apiRequest({ action: 'get_messages', target_user: state.activeChat });
        if (res.status === 'success' && res.data) {
            box.innerHTML = res.data.map(m => `<div class="msg ${m.sender === state.user.name ? 'me' : 'them'}">${m.content}</div>`).join('') || "No messages yet. Say hi!";
            box.scrollTop = box.scrollHeight;
        }
    },
    async sendMessage() {
        const input = document.getElementById('msg-input');
        const content = input.value.trim();
        if (!content || !state.activeChat) return;
        
        // 立即上屏
        const box = document.getElementById('chat-box');
        box.innerHTML += `<div class="msg me">${content}</div>`;
        box.scrollTop = box.scrollHeight;
        
        input.value = "";
        
        // 后台发送
        await apiRequest({ action: 'send_message', target_user: state.activeChat, content });
    },
    insertEmoji(e) {
        const input = document.getElementById('msg-input');
        const start = input.selectionStart ?? input.value.length;
        input.value = input.value.slice(0, start) + e + input.value.slice(start);
        input.focus();
        input.selectionStart = input.selectionEnd = start + e.length;
    }
};

/* ================== 小说阅读器 ================== */

const reader={
    async ensureReady(){
        if(!state.novel.initialized){
            await this.init();
            state.novel.initialized=true;
        }
    },
    async init(){
        const textArea=document.getElementById('reader-text-area');
        try{
            const [novelResponse,commentRes]=await Promise.all([
                fetch('novel.txt'),
                apiRequest({action:'get_all_comments'})
            ]);
            if(!novelResponse.ok) throw new Error('novel.txt not found in your repo.');
            const text=await novelResponse.text();
            state.novel.lines=text.replace(/\r\n/g,"\n").split('\n');
            if(commentRes.status==='success') state.novel.comments=commentRes.data||{};
            this.parseAndPaginate();
            visuals.initReaderBG();
        }catch(err){
            console.error(err);
            textArea.innerHTML=`<p style="text-align:center;color:var(--pink);">${err.message}</p>`;
        }
    },
    parseAndPaginate(){
    const lines = state.novel.lines;

    // ✅ 1. 更严格的章节识别：行首 + 章/话/回/卷 + 常见特例
    const chapterRegex = /^(第.{1,12}[章话回卷]|序章|终章|Prologue|Epilogue|Chapter\s+\d+)/i;

    const pages = [];
    const toc   = [];
    let currentStart = 0;
    let buffer = [];
    const LPP = state.novel.linesPerPage;

    const flushPage = (endIndex)=>{
        if(endIndex > currentStart){
            pages.push({ start: currentStart, end: endIndex });
        }
    };

    for(let i=0;i<lines.length;i++){
        const line = lines[i];
        const pure = line.replace(/\s/g,"");
        const isChapter = chapterRegex.test(pure);

        // 碰到新章节标题：如果当前页已有内容，先结算上一页
        if(isChapter && buffer.length > 0){
            flushPage(i);
            currentStart = i;   // 新页从本章节标题开始
            buffer = [];
        }

        // 只记录“章节标题行”到目录，不再提前猜 pageIndex
        if(isChapter){
            toc.push({
                title: line.trim() || `Chapter @${i+1}`,
                lineIndex: i
            });
        }

        buffer.push(line);

        // 正常按 LPP 行数分页
        if(buffer.length >= LPP){
            flushPage(i+1);
            currentStart = i+1;
            buffer = [];
        }
    }

    // 收尾：最后一页
    if(buffer.length > 0){
        flushPage(lines.length);
    }

    state.novel.pages      = pages;
    state.novel.totalPages = pages.length;

    // ✅ 2. 在分页完成之后，再统一给 TOC 补上正确的 pageIndex
    state.novel.toc = toc.map(ch=>{
        const pageIndex = pages.findIndex(p => ch.lineIndex >= p.start && ch.lineIndex < p.end);
        return { ...ch, pageIndex };
    });

    this.renderTOC();
    this.loadBookmarks();
    this.renderBookmarks();
    this.goToPage(0);
},
    goToPage(page){
        if(page<0 || page>=state.novel.totalPages) return;
        state.novel.currentPage=page;
        const seg=state.novel.pages[page];
        const start=seg.start,end=seg.end;
        const textArea=document.getElementById('reader-text-area');
        const html=state.novel.lines.slice(start,end).map((line,i)=>{
            const idx=start+i;
            if(!line.trim()) return '<br>';
            const cnt=state.novel.comments[idx]?state.novel.comments[idx].length:0;
            return `<div class="line" data-line-index="${idx}">
                ${line}
                <div class="comment-bubble" onclick="reader.openCommentSidebar(${idx})">
                    <span class="comment-icon">♟</span>
                    ${cnt>0?`<span class="comment-count">${cnt}</span>`:""}
                </div>
            </div>`;
        }).join('');
        textArea.innerHTML=html;
        textArea.scrollTop=0;
        document.getElementById('reader-progress').innerText=`${page+1} / ${state.novel.totalPages}`;
    },
    goToChapter(lineIndex){
        const pageIdx=state.novel.pages.findIndex(p=>lineIndex>=p.start && lineIndex<p.end);
        if(pageIdx>=0) this.goToPage(pageIdx);
    },
    switchTab(tab){
        document.getElementById('tab-toc').classList.toggle('active',tab==='toc');
        document.getElementById('content-toc').classList.toggle('hidden',tab!=='toc');
        document.getElementById('tab-bm').classList.toggle('active',tab==='bm');
        document.getElementById('content-bm').classList.toggle('hidden',tab!=='bm');
    },
    renderTOC(){
        const c=document.getElementById('content-toc');
        if(state.novel.toc.length===0){
            c.innerHTML=`<p style="padding:12px;color:#888;">No chapter titles detected.</p>`;
            return;
        }
        c.innerHTML=state.novel.toc.map(ch=>`
            <div class="toc-item" onclick="reader.goToChapter(${ch.lineIndex})">
                <strong>${ch.title}</strong>
                <small>Page ${ch.pageIndex+1}</small>
            </div>`).join('');
    },
    loadBookmarks(){
        state.novel.bookmarks=JSON.parse(localStorage.getItem('ngnl_bookmarks')||'[]');
    },
    renderBookmarks(){
        const c=document.getElementById('content-bm');
        if(state.novel.bookmarks.length===0){
            c.innerHTML=`<p style="padding:12px;color:#888;">No bookmarks yet.</p>`;
            return;
        }
        c.innerHTML=state.novel.bookmarks.map((bm,idx)=>`
            <div class="bm-item" onclick="reader.goToPage(${bm.page})">
                Page ${bm.page+1} - ${bm.line.substring(0,20)}...
                <button onclick="reader.removeBookmark(${idx},event)" style="float:right;background:none;border:none;color:var(--pink);font-size:.8rem;">X</button>
            </div>`).join('');
    },
    addBookmark(){
        const p=state.novel.currentPage;
        if(state.novel.bookmarks.some(b=>b.page===p)) return alert("This page is already bookmarked.");
        const seg=state.novel.pages[p];
        const firstLine=state.novel.lines[seg.start]||"Empty Page";
        state.novel.bookmarks.push({page:p,line:firstLine});
        localStorage.setItem('ngnl_bookmarks',JSON.stringify(state.novel.bookmarks));
        this.renderBookmarks();
        alert(`Page ${p+1} bookmarked!`);
    },
    removeBookmark(i,e){
        e.stopPropagation();
        if(!confirm("Remove this bookmark?")) return;
        state.novel.bookmarks.splice(i,1);
        localStorage.setItem('ngnl_bookmarks',JSON.stringify(state.novel.bookmarks));
        this.renderBookmarks();
    },
    openCommentSidebar(lineIndex){
        state.novel.activeCommentLine=lineIndex;
        document.getElementById('cmt-header-title').innerText=`Line ${lineIndex+1}`;
        const cList=document.getElementById('cmt-list');
        const arr=state.novel.comments[lineIndex]||[];
        if(arr.length===0){
            cList.innerHTML=`<p style="text-align:center;color:#888;padding:20px;">No comments yet. Be the first!</p>`;
        }else{
            cList.innerHTML=arr.map(reader.formatComment).join('');
        }
        document.getElementById('reader-comment-sidebar').classList.add('open');
    },
    closeCommentSidebar(){
        document.getElementById('reader-comment-sidebar').classList.remove('open');
    },
    formatComment(c){
        const content=c.content.replace(/@(\w+)/g,`<span class="mention-link" onclick="ui.showOtherUserProfile('$1')">@$1</span>`);
        const style = ui.renderUserStyle(c);
        return `<div class="cmt-card">
            <div class="cmt-user">
                ${style.avatarHTML}
                <div>
                    <div>${style.nameHTML}</div>
                    ${style.subHTML ? `<div class="cmt-meta">${style.subHTML}</div>` : ""}
                </div>
            </div>
            <div class="cmt-content">${content}</div>
            <div class="cmt-actions">
                <span onclick="community.interact('like','${c.id}','comment')">♥ ${c.likes}</span>
                <span onclick="community.interact('tip','${c.id}','comment')">🪙 ${c.coins||0}</span>
            </div>
        </div>`;
    },
    async postComment(){
        const input=document.getElementById('cmt-input');
        const content=input.value.trim();
        if(!content || state.novel.activeCommentLine<0) return;
        if(!state.isLoggedIn) return alert("You must be logged in to comment.");
        input.disabled=true;
        await apiRequest({action:'post_line_comment',line_index:state.novel.activeCommentLine,content});
        input.value="";input.disabled=false;
        const res=await apiRequest({action:'get_all_comments'});
        if(res.status==='success'){
            state.novel.comments=res.data||{};
            this.goToPage(state.novel.currentPage);
            this.openCommentSidebar(state.novel.activeCommentLine);
        }
    }
};

/* ================== 点赞 / 打赏 ================== */

const community={
    async interact(subAction,id,type){
        if(!state.isLoggedIn) return alert("Login required.");
        if(subAction==='tip' && !confirm("Spend 1 coin?")) return;
        const res=await apiRequest({action:'interact',sub_action:subAction,type,id});
        if(res.status==='success'){
            if(subAction==='tip' && typeof res.new_balance!=='undefined'){
                state.user.coins=res.new_balance;
                sessionStorage.setItem('ngnlUser',JSON.stringify(state.user));
                ui.updateHUD();
            }
            // 同步评论 + 讨论区展示
            const [cRes,dRes]=await Promise.all([
                apiRequest({action:'get_all_comments'}),
                apiRequest({action:'get_discussions'})
            ]);
            if(cRes.status==='success'){
                state.novel.comments=cRes.data||{};
                reader.goToPage(state.novel.currentPage);
                if(state.novel.activeCommentLine>=0) reader.openCommentSidebar(state.novel.activeCommentLine);
            }
            if(dRes.status==='success') forum.render(dRes.data);
        }else alert(res.message);
    }
};
/* ================== ANIME 播放器（全站同步 + 实时轮询版） ================== */

const animePage = {
    state: {
        initialized: false,
        currentSeriesId: null,
        currentEpIndex: 0,
        danmakuOn: true,
        autoNext: true,
        lastSaveTime: 0,
        
        // 弹幕核心数据
        danmakuMap: [],   // 弹幕池
        danmakuIds: new Set(), // ID去重池 (新增)
        dmCursor: 0,      
        
        // 轮询定时器 (新增)
        pollTimer: null,
        
        // 轨道管理
        lanes: { scroll: [], top: [], bottom: [] },
        
        favSet: new Set()
    },
    dom: {},

    ensureReady() {
        if (this.state.initialized) return;
        this.init();
        this.state.initialized = true;
    },

    init() {
        this.dom = {
            list: document.getElementById('anime-list'),
            video: document.getElementById('anime-video'),
            dmLayer: document.getElementById('anime-danmaku-layer'),
            dmInput: document.getElementById('anime-danmaku-input'),
            dmSendBtn: document.getElementById('anime-danmaku-send'),
            dmToggle: document.getElementById('anime-dm-toggle'),
            dmMode: document.getElementById('anime-dm-mode'),
            dmColor: document.getElementById('anime-dm-color'),
            speedSel: document.getElementById('anime-speed'),
            autoNext: document.getElementById('anime-autonext'),
            favBtn: document.getElementById('anime-fav-btn'),
            titleBar: document.getElementById('anime-current-title'),
            cList: document.getElementById('anime-comment-list'),
            cInput: document.getElementById('anime-comment-input'),
            cSendBtn: document.getElementById('anime-comment-send')
        };

        this.renderList();
        this.loadLocalSettings();
        this.bindEvents();

        // 默认加载第一集 (修改：传入 false 禁止自动播放)
        const first = ANIME_DATA[0];
        if (first) {
            try {
                const saved = JSON.parse(localStorage.getItem('ngnlAnimeLast') || 'null');
                if (saved && saved.seriesId) {
                    // 恢复上次进度，但不自动播放
                    this.playEpisode(saved.seriesId, saved.epIndex, saved.currentTime, false);
                } else {
                    // 加载第一集，不自动播放
                    this.playEpisode(first.id, 0, 0, false);
                }
            } catch (e) {
                this.playEpisode(first.id, 0, 0, false);
            }
        }
    },

    bindEvents() {
        this.dom.list.addEventListener('click', e => {
            const card = e.target.closest('.anime-card');
            if (!card) return;
            const sid = card.getAttribute('data-series');
            const idx = parseInt(card.getAttribute('data-index'), 10);
            // 修改：点击选集时，强制自动播放 (true)
            this.playEpisode(sid, idx, 0, true);
        });

        this.dom.speedSel.addEventListener('change', () => {
            this.dom.video.playbackRate = parseFloat(this.dom.speedSel.value);
        });
        this.dom.dmToggle.addEventListener('change', () => {
            this.state.danmakuOn = this.dom.dmToggle.checked;
            this.dom.dmLayer.style.display = this.state.danmakuOn ? 'block' : 'none';
        });
        this.dom.autoNext.addEventListener('change', () => {
            this.state.autoNext = this.dom.autoNext.checked;
        });

        const sendAction = () => this.sendDanmaku();
        this.dom.dmSendBtn.addEventListener('click', sendAction);
        this.dom.dmInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') sendAction();
        });

        this.dom.cSendBtn.addEventListener('click', () => this.sendComment());
        this.dom.favBtn.addEventListener('click', () => this.toggleFav());

        this.dom.video.addEventListener('timeupdate', () => this.handleTimeUpdate());
        this.dom.video.addEventListener('ended', () => {
            if (this.state.autoNext) this.playNextEpisode();
        });
        
        this.dom.video.addEventListener('seeking', () => {
             const t = this.dom.video.currentTime;
             this.state.dmCursor = 0;
             while(this.state.dmCursor < this.state.danmakuMap.length && this.state.danmakuMap[this.state.dmCursor].at < t){
                 this.state.dmCursor++;
             }
             this.dom.dmLayer.innerHTML = '';
             this.state.lanes = { scroll: [], top: [], bottom: [] };
        });
    },

    loadLocalSettings() {
        const sp = localStorage.getItem('ngnlAnimeSpeed');
        if (sp) {
            this.dom.speedSel.value = sp;
            this.dom.video.playbackRate = parseFloat(sp);
        }
        try {
            const f = JSON.parse(localStorage.getItem('ngnlAnimeFav') || '[]');
            this.state.favSet = new Set(f);
        } catch(e) {}
    },

    getEpisodeKey(sid, idx) { return sid + '_' + idx; },

    // ================= 核心播放逻辑 =================
    // ================= 核心播放逻辑 =================
    // 修改：第4个参数改为 autoPlay
    async playEpisode(seriesId, index, resumeTime = 0, autoPlay = true) {
        // 切换集数时，先清除旧的轮询
        if (this.state.pollTimer) clearInterval(this.state.pollTimer);

        const series = ANIME_DATA.find(s => s.id === seriesId);
        if (!series) return;
        const ep = series.episodes[index];
        if (!ep) return;

        this.state.currentSeriesId = seriesId;
        this.state.currentEpIndex = index;
        this.state.dmCursor = 0;
        this.state.prevTime = 0;
        this.state.danmakuMap = []; 
        this.state.danmakuIds.clear(); // 清除 ID 缓存
        this.dom.dmLayer.innerHTML = '';

        this.highlightCurrentCard();
        this.dom.titleBar.innerText = `${series.title} - ${ep.title}`;
        this.updateFavButton();

        this.dom.video.src = ep.url;
        this.dom.video.currentTime = resumeTime;
        
        // 初次加载数据
        await this.loadRemoteData(seriesId, index);

        // 启动实时轮询 (每 10 秒)
        this.state.pollTimer = setInterval(() => {
            this.pollNewDanmaku();
        }, 10000);
        
        // 修改：只有当 autoPlay 为 true 时才调用 play()
        if (autoPlay) {
            try {
                await this.dom.video.play();
            } catch (e) {
                console.log("Autoplay blocked or disabled.");
            }
        }
    },

    highlightCurrentCard() {
        this.dom.list.querySelectorAll('.anime-card').forEach(c => c.classList.remove('active'));
        const target = this.dom.list.querySelector(`.anime-card[data-series="${this.state.currentSeriesId}"][data-index="${this.state.currentEpIndex}"]`);
        if (target) {
            target.classList.add('active');
            target.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
    },

    // ================= 数据同步 (API) =================
    async loadRemoteData(sid, epIndex) {
        const epStr = String(epIndex);
        
        // 1. 获取弹幕
        const dRes = await apiRequest({ action: 'get_danmaku', animeId: sid, episode: epStr });
        if (dRes.status === 'success') {
            this.mergeDanmaku(dRes.data);
            console.log(`Loaded ${this.state.danmakuMap.length} danmaku.`);
        }

        // 2. 获取评论
        const cRes = await apiRequest({ action: 'get_anime_comments', animeId: sid, episode: epStr });
        if (cRes.status === 'success') {
            this.renderComments(cRes.data);
        } else {
            this.dom.cList.innerHTML = '<p style="color:#666">No comments yet.</p>';
        }
    },

    // 实时轮询新弹幕
    async pollNewDanmaku() {
        const sid = this.state.currentSeriesId;
        const epIndex = this.state.currentEpIndex;
        // 如果视频暂停，暂时不轮询以节省资源（可选）
        if (this.dom.video.paused) return;

        const res = await apiRequest({ 
            action: 'get_danmaku', 
            animeId: sid, 
            episode: String(epIndex) 
        });

        if (res.status === 'success') {
            this.mergeDanmaku(res.data);
        }
    },

    // 合并去重弹幕
    mergeDanmaku(newList) {
        let added = false;
        const currentTime = this.dom.video.currentTime;

        newList.forEach(dm => {
            // 如果这个弹幕ID没见过
            if (!this.state.danmakuIds.has(dm.id)) {
                this.state.danmakuIds.add(dm.id);
                this.state.danmakuMap.push(dm);
                added = true;

                // 如果是新来的弹幕，且时间点刚好在当前播放时间附近 (误差 5秒内)，直接渲染上屏，实现“伪直播”效果
                if (Math.abs(dm.at - currentTime) < 5) {
                    this.spawnDanmaku(dm);
                }
            }
        });

        if (added) {
            // 重新按时间排序
            this.state.danmakuMap.sort((a, b) => a.at - b.at);
            // 重置游标位置，防止排序后游标错位
            // (简单做法：游标不动，下一帧 handleTimeUpdate 会自动追赶)
        }
    },

    async refreshFavorites() {
        if (!state.isLoggedIn) return;
        const res = await apiRequest({ action: 'get_favorites' });
        if (res.status === 'success') {
            const keys = res.data.map(f => this.getEpisodeKey(f.animeId, f.episode));
            this.state.favSet = new Set(keys);
            localStorage.setItem('ngnlAnimeFav', JSON.stringify(keys));
            this.updateFavButton();
        }
    },

    // ================= 弹幕渲染 =================
    handleTimeUpdate() {
        const v = this.dom.video;
        const t = v.currentTime;

        // 进度保存
        const now = Date.now();
        if (now - this.state.lastSaveTime > 5000) {
            this.state.lastSaveTime = now;
            localStorage.setItem('ngnlAnimeLast', JSON.stringify({
                seriesId: this.state.currentSeriesId,
                epIndex: this.state.currentEpIndex,
                currentTime: t
            }));
        }

        if (!this.state.danmakuOn) return;

        const list = this.state.danmakuMap;
        while (this.state.dmCursor < list.length) {
            const dm = list[this.state.dmCursor];
            if (dm.at <= t && dm.at > t - 1.0) {
                this.spawnDanmaku(dm);
                this.state.dmCursor++;
            } else if (dm.at > t) {
                break; 
            } else {
                this.state.dmCursor++; 
            }
        }
    },

    spawnDanmaku(data) {
        const { text, color, mode, size } = data;
        if (!text) return;

        const el = document.createElement('div');
        el.innerText = text;
        el.className = 'dm-item';
        el.style.color = color || '#ffffff';
        if (size === 'small') el.style.fontSize = '18px';
        else if (size === 'large') el.style.fontSize = '28px';
        else el.style.fontSize = '22px';

        const containerH = this.dom.dmLayer.clientHeight;
        const modeType = mode || 'scroll';

        if (modeType === 'top') {
            el.classList.add('dm-top');
            this.dom.dmLayer.appendChild(el);
            const offset = (document.querySelectorAll('.dm-top').length - 1) * 30;
            el.style.top = (20 + (offset % (containerH/2))) + 'px';
        } else if (modeType === 'bottom') {
            el.classList.add('dm-bottom');
            this.dom.dmLayer.appendChild(el);
            const offset = (document.querySelectorAll('.dm-bottom').length - 1) * 30;
            el.style.bottom = (40 + (offset % (containerH/2))) + 'px';
        } else {
            el.classList.add('dm-scroll');
            this.dom.dmLayer.appendChild(el);
            const maxLanes = Math.floor(containerH / 30); 
            const lane = Math.floor(Math.random() * maxLanes);
            el.style.top = (lane * 30) + 'px';
        }

        el.addEventListener('animationend', () => el.remove());
    },

    async sendDanmaku() {
        if (!state.isLoggedIn) return alert("Please login to send danmaku.");
        const text = this.dom.dmInput.value.trim();
        if (!text) return;

        const time = this.dom.video.currentTime;
        const color = this.dom.dmColor.value;
        const mode = this.dom.dmMode.value;

        // 本地立即上屏
        // 注意：spawnDanmaku 不会把弹幕加入 danmakuMap，防止重复
        this.spawnDanmaku({ text, color, mode, at: time });
        this.dom.dmInput.value = '';

        // 发送到服务器
        const res = await apiRequest({
            action: 'post_danmaku',
            animeId: this.state.currentSeriesId,
            episode: String(this.state.currentEpIndex), // ⭐ 关键修复：转为 String
            text: text,
            at: time,
            color: color,
            mode: mode
        });

        if (res.status === 'success') {
            // 收到成功回执后，加入本地缓存，防止回放时消失
            // 生成一个临时 ID 防止冲突 (或等待轮询拉取)
            // 这里我们手动加进去，并给一个临时 ID
            const tempId = "local_" + Date.now();
            const newDm = { id: tempId, text, color, mode, at: time };
            this.state.danmakuIds.add(tempId);
            this.state.danmakuMap.push(newDm);
            this.state.danmakuMap.sort((a,b)=>a.at - b.at);
        } else {
            console.error("Danmaku send failed:", res.message);
        }
    },

    // ================= 评论 & 收藏 =================
    renderComments(list) {
        if (!list || list.length === 0) return;
        this.dom.cList.innerHTML = list.map(c => {
             const style = ui.renderUserStyle(c);
             return `
             <div class="anime-comment-card">
                <div class="anime-comment-header">
                    ${style.avatarHTML}
                    <div style="margin-left:8px;">
                        <span style="font-weight:bold;color:#ccc;font-size:0.9rem">${c.user}</span>
                        <span style="margin-left:8px;font-size:0.7rem;color:#666">${c.time}</span>
                    </div>
                </div>
                <div class="anime-comment-body" style="padding-left:36px;margin-top:2px;">${c.content}</div>
             </div>`;
        }).join('');
    },

    async sendComment() {
        if (!state.isLoggedIn) return alert("Login required.");
        const content = this.dom.cInput.value.trim();
        if (!content) return;
        
        this.dom.cInput.value = '';
        const res = await apiRequest({
            action: 'post_anime_comment',
            animeId: this.state.currentSeriesId,
            episode: String(this.state.currentEpIndex), // ⭐ 关键修复
            content: content
        });
        
        if (res.status === 'success') {
            this.loadRemoteData(this.state.currentSeriesId, this.state.currentEpIndex);
        } else {
            alert(res.message);
        }
    },

    updateFavButton() {
        const key = this.getEpisodeKey(this.state.currentSeriesId, this.state.currentEpIndex);
        const isFav = this.state.favSet.has(key);
        this.dom.favBtn.innerText = isFav ? "★ 已收藏" : "☆ 收藏本集";
        this.dom.favBtn.classList.toggle('fav-on', isFav);
    },

    async toggleFav() {
        if (!state.isLoggedIn) return alert("Login required.");
        const key = this.getEpisodeKey(this.state.currentSeriesId, this.state.currentEpIndex);
        
        const isFav = this.state.favSet.has(key);
        if (isFav) this.state.favSet.delete(key);
        else this.state.favSet.add(key);
        this.updateFavButton();

        const res = await apiRequest({
            action: 'toggle_favorite',
            animeId: this.state.currentSeriesId,
            episode: String(this.state.currentEpIndex) // ⭐ 关键修复
        });

        if (res.status !== 'success') {
            alert("Sync failed: " + res.message);
            if (isFav) this.state.favSet.add(key);
            else this.state.favSet.delete(key);
            this.updateFavButton();
        } else {
            localStorage.setItem('ngnlAnimeFav', JSON.stringify(Array.from(this.state.favSet)));
        }
    },

    playNextEpisode() {
        const series = ANIME_DATA.find(s => s.id === this.state.currentSeriesId);
        if (!series) return;
        if (this.state.currentEpIndex + 1 < series.episodes.length) {
            this.playEpisode(this.state.currentSeriesId, this.state.currentEpIndex + 1);
        } else {
            alert("Current series finished!");
        }
    },
    
    renderList(){
        const html = ANIME_DATA.map(series=>{
            return `
            <div class="anime-series-block">
                <div style="font-size:.8rem;color:#999;margin:6px 2px 2px;border-bottom:1px solid #333;padding-bottom:2px;">${series.title}</div>
                ${series.episodes.map((ep,idx)=>`
                    <div class="anime-card" 
                         data-series="${series.id}" 
                         data-index="${idx}">
                        <div class="anime-card-title">${ep.title}</div>
                        <div class="anime-card-ep">EP ${ep.no}</div>
                    </div>
                `).join('')}
            </div>`;
        }).join('');
        this.dom.list.innerHTML = html;
    }
};

/* ================== 讨论区 ================== */

const forum={
    async init(){
        const res=await apiRequest({action:'get_discussions'});
        if(res.status==='success') this.render(res.data);
    },
    render(list){
        const box=document.getElementById('forum-list');
        if(!list || list.length===0){
            box.innerHTML=`<p style="color:#888;padding:10px;">No posts yet. Be the first challenger.</p>`;
            return;
        }
        box.innerHTML=list.map(p=>{
            const style = ui.renderUserStyle(p);
            const content=p.content.replace(/@(\w+)/g,`<span class="mention-link" onclick="ui.showOtherUserProfile('$1')">@$1</span>`);
            return `<div class="post-card">
                ${style.avatarHTML}
                <div class="post-main">
                    <div class="post-header">
                        ${style.nameHTML}
                    </div>
                    <div class="post-content">${content}</div>
                    <div class="post-meta">${p.time}</div>
                    <div class="post-actions">
                        <span onclick="community.interact('like','${p.id}','discussion')">♥ ${p.likes}</span>
                        <span onclick="community.interact('tip','${p.id}','discussion')">🪙 ${p.coins||0}</span>
                    </div>
                </div>
            </div>`;
        }).join('');
    },
    async post(){
        const input=document.getElementById('forum-input');
        const content=input.value.trim();
        if(!content) return;
        if(!state.isLoggedIn) return alert("Login required.");
        input.disabled=true;
        const res=await apiRequest({action:'post_discussion',content});
        input.disabled=false;
        if(res.status==='success'){
            input.value="";
            this.init();
        }else alert(res.message);
    }
};

/* ================== 商店（对接后端 get_shop / buy_item） ================== */

const shop={
    async init(){
        await this.refresh();
    },
    async refresh(){
        ui.updateHUD();
        const grid=document.getElementById('shop-grid');
        grid.innerHTML="<p>Loading shop...</p>";
        const res=await apiRequest({action:'get_shop'});
        if(res.status!=='success'){
            grid.innerHTML=`<p style="color:var(--pink);">${res.message}</p>`;
            return;
        }
        const ownedMap=res.owned || {};
        const styles=res.styles || {};
        state.user.frameKey = styles.frameKey || state.user.frameKey;
        state.user.titleKey = styles.titleKey || state.user.titleKey;
        state.user.sigKey   = styles.sigKey   || state.user.sigKey;
        ui.updateProfileView();
        this.render(res.items || [], ownedMap, styles);
    },
    render(items, ownedMap, styles){
        const grid=document.getElementById('shop-grid');
        grid.innerHTML=items.map(it=>{
            const own = ownedMap[it.key];
            const isActive =
                (it.category==='frame' && styles.frameKey===it.key) ||
                (it.category==='title' && styles.titleKey===it.key) ||
                (it.category==='signature' && styles.sigKey===it.key);
            const btnLabel = own ? (isActive ? "EQUIPPED" : "EQUIP") : `BUY (${it.price}🪙)`;
            const disabled = isActive ? "disabled" : "";
            const ownedTag = own ? `<div class="shop-owned">OWNED</div>` : "";
            return `<div class="shop-card">
                <div class="shop-inner">
                    <div class="shop-tag">${it.category.toUpperCase()}</div>
                    <div class="shop-name">${it.name}</div>
                    <div class="shop-price">Price: ${it.price} 🪙</div>
                    <div class="shop-desc">${it.desc}</div>
                    ${ownedTag}
                    <button class="btn" style="width:100%;margin-top:6px;" ${disabled}
                        onclick="shop.buy('${it.key}')">${btnLabel}</button>
                </div>
            </div>`;
        }).join('');
        ui.updateHUD();
    },
    async buy(key){
        const res=await apiRequest({action:'buy_item',key});
        if(res.status!=='success'){
            alert(res.message);
            return;
        }
        state.user.coins = res.new_balance;
        if(res.styles){
            state.user.frameKey = res.styles.frameKey || state.user.frameKey;
            state.user.titleKey = res.styles.titleKey || state.user.titleKey;
            state.user.sigKey   = res.styles.sigKey   || state.user.sigKey;
        }
        sessionStorage.setItem('ngnlUser',JSON.stringify(state.user));
        ui.updateHUD();
        ui.updateProfileView();
        this.refresh();
    }
};

/* ================== 视觉效果（角色卡 / 背景） ================== */

const visuals={
    init(){
        this.initPlayers();
        this.initCursor();
        this.initCanvas();
        this.initRaces();
        this.initEmojiBar();
    },
    initPlayers(){
        const players=[
            {n:'IZUNA',r:'Warbeast / Knight',img:'izuna.png',d:'拥有“血坏”的兽人少女，瞬间读取场上的一切信息。'},
            {n:'JIBRIL',r:'Flügel / Bishop',img:'jibril.png',d:'狂热的知识收集狂，掌握毁灭级魔法的天翼种。'},
            {n:'SHIRO',r:'Imanity / Queen',img:'shiro.png',d:'计算力超越人类极限的天才少女，是『　　』的头脑。'},
            {n:'SORA',r:'Imanity / King',img:'sora.png',d:'读心级心理战高手，相信“人类的可能性”胜过一切。'},
            {n:'STEPH',r:'Imanity / Pawn',img:'steph.png',d:'艾尔奇亚公主，虽不擅游戏，却用执着与温柔支撑王国。'},
            {n:'TET',r:'OldDeus / Joker',img:'tet.png',d:'唯一神，支配棋盘的观战者与发起者。'}
        ];
        document.getElementById('char-grid').innerHTML=players.map(p=>`
            <div class="char-card">
                <div class="char-inner">
                    <div class="char-face char-front">
                        <img src="${p.img}" alt="${p.n}">
                        <div class="char-front-info">
                            <div class="char-name">${p.n}</div>
                            <div class="char-race">${p.r}</div>
                        </div>
                    </div>
                    <div class="char-face char-back">
                        <div class="card-symbol">♜</div>
                        <p class="char-desc">${p.d}</p>
                    </div>
                </div>
            </div>`).join('');
    },
    initCursor(){
        const cursor=document.getElementById('cursor');
        document.addEventListener('mousemove',e=>{
            cursor.style.left=e.clientX+'px';
            cursor.style.top=e.clientY+'px';
        });
        document.body.addEventListener('mouseover',e=>{
            if(e.target.closest('a,button,.btn,.char-card,.f-item,.auth-link,[onclick]')) cursor.classList.add('hover');
            else cursor.classList.remove('hover');
        });
        document.addEventListener('mousedown',()=>cursor.classList.add('click'));
        document.addEventListener('mouseup',()=>cursor.classList.remove('click'));
    },
    initCanvas(){
        const cvs=document.getElementById('canvas-bg'),ctx=cvs.getContext('2d');
        let w=window.innerWidth,h=window.innerHeight;
        cvs.width=w;cvs.height=h;
        const particles=Array.from({length:60},()=>({
            x:Math.random()*w,
            y:Math.random()*h,
            s:Math.random()*0.6+0.2,
            char:['♔','♕','♖','♗','♘','♙'][Math.floor(Math.random()*6)],
            opacity:Math.random()*0.4+0.2
        }));
        function loop(){
            ctx.clearRect(0,0,w,h);
            particles.forEach(p=>{
                p.y-=p.s;
                if(p.y<-40){p.y=h+40;p.x=Math.random()*w;}
                ctx.fillStyle=`rgba(255,255,255,${p.opacity})`;
                ctx.font='22px Orbitron';
                ctx.fillText(p.char,p.x,p.y);
            });
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
        window.addEventListener('resize',()=>{
            w=window.innerWidth;h=window.innerHeight;
            cvs.width=w;cvs.height=h;
        });
    },
    initReaderBG(){
        const cvs=document.getElementById('reader-bg-canvas');
        if(!cvs.getContext) return;
        const ctx=cvs.getContext('2d');
        function resize(){
            const panel=document.querySelector('.r-main-panel');
            if(!panel) return;
            cvs.width=panel.clientWidth;
            cvs.height=panel.clientHeight;
        }
        resize();
        const dots=Array.from({length:80},()=>({
            x:Math.random()*cvs.width,
            y:Math.random()*cvs.height,
            r:Math.random()*2+1,
            vy:Math.random()*0.4+0.2
        }));
        let scrollFactor=0;
        const textArea=document.getElementById('reader-text-area');
        textArea.addEventListener('scroll',()=>{scrollFactor=textArea.scrollTop/200;});
        function draw(){
            ctx.clearRect(0,0,cvs.width,cvs.height);
            const gradient=ctx.createRadialGradient(cvs.width/2,cvs.height/2,0,cvs.width/2,cvs.height/2,cvs.width/1.2);
            gradient.addColorStop(0,'rgba(5,217,232,0.35)');
            gradient.addColorStop(0.5,'rgba(217,5,232,0.15)');
            gradient.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=gradient;
            ctx.fillRect(0,0,cvs.width,cvs.height);
            dots.forEach(d=>{
                d.y-=d.vy+scrollFactor*0.3;
                if(d.y<-10){d.y=cvs.height+10;d.x=Math.random()*cvs.width;}
                ctx.beginPath();
                ctx.fillStyle='rgba(255,255,255,0.7)';
                ctx.arc(d.x,d.y,d.r,0,Math.PI*2);
                ctx.fill();
            });
            requestAnimationFrame(draw);
        }
        window.addEventListener('resize',resize);
        requestAnimationFrame(draw);
    },
    initRaces(){
        // tier: god(金), high(紫), mid(绿/青), low(红), imanity(白)
        const races = [
            { r: 1,  en: "Old Deus",      cn: "神灵种", piece: "♔", tier: "god",  desc: "由星球的概念获得意志而诞生的神。拥有无限的寿命与全知全能的力量，是盟约之前的统治者。" },
            { r: 2,  en: "Phantasma",     cn: "幻想种", piece: "♕", tier: "high", desc: "由“世界”本身的意志分化而成的生命体，没有实体，大多生存在异空间中。" },
            { r: 3,  en: "Elemental",     cn: "精灵种", piece: "♗", tier: "high", desc: "构成世界魔法源流“精灵回廊”本身的种族，是一切魔法的根源。" },
            { r: 4,  en: "Dragonia",      cn: "龙精种", piece: "♖", tier: "high", desc: "拥有最强物理力量的生物。以巨大的生命力支付代价，能行使足以弑神的破坏力。" },
            { r: 5,  en: "Gigant",        cn: "巨人种", piece: "♖", tier: "mid",  desc: "拥有巨大的身躯和怪力，能轻易改变地形。虽然头脑简单，但战斗力极强。" },
            { r: 6,  en: "Flügel",        cn: "天翼种", piece: "♕", tier: "high", desc: "战神阿尔特修创造的“弑神兵器”。拥有永恒的生命，以知识（书本）为食，也就是“天杀的”。" },
            { r: 7,  en: "Elf",           cn: "森精种", piece: "♖", tier: "mid",  desc: "拥有仅次于神灵种的高超魔法适性。建立了名为“爱尔文·加尔得”的世界最大国家，有点看不起人。" },
            { r: 8,  en: "Dwarf",         cn: "地精种", piece: "♗", tier: "mid",  desc: "拥有极高的工学和机械造诣，曾制造出能毁灭神灵种的决战兵器“髓爆”。与森精种是死对头。" },
            { r: 9,  en: "Fairy",         cn: "妖精种", piece: "P", tier: "mid",  desc: "居住在精灵回廊中的微小生命，通常作为森精种魔法实验的协助者（或使魔）。" },
            { r: 10, en: "Ex-Machina",    cn: "机凯种", piece: "♗", tier: "mid",  desc: "机械构成的群体生命。拥有无限进化的“演算”能力，能解析并复制一切攻击。曾是弑神的主力。" },
            { r: 11, en: "Demonia",       cn: "妖魔种", piece: "P", tier: "low",  desc: "魔王为了战争而创造的种族。智力较低但好战，拥有多样的形态。" },
            { r: 12, en: "Dhampir",       cn: "吸血种", piece: "♘", tier: "low",  desc: "以体液（灵魂）为食。擅长幻术与精神控制。若吸食血液能发挥真正力量，但会患上致死疾病。" },
            { r: 13, en: "Lunamana",      cn: "月咏种", piece: "♖", tier: "low",  desc: "居住在红月之上的神秘种族。由于距离地面太远，关于她们的情报极少。" },
            { r: 14, en: "Warbeast",      cn: "兽人种", piece: "P", tier: "low",  desc: "拥有超越物理极限的五感与身体能力。能通过“血坏”短暂突破界限。曾建立东部联合。" },
            { r: 15, en: "Seiren",        cn: "海栖种", piece: "♘", tier: "low",  desc: "居住在深海的种族。全是女性，只有通过与其他种族交配才能繁衍，被称为“笨蛋”。" },
            { r: 16, en: "Imanity",       cn: "人类种", piece: "♔", tier: "imanity", desc: "最弱的种族。没有魔法，没有感应力，甚至连身体能力也最弱。但正因一无所有，才拥有无限的“可能性”。" }
        ];

        const container = document.getElementById('race-list-container');
        if(!container) return;

        container.innerHTML = races.map(race => {
            return `
            <div class="race-card" data-tier="${race.tier}" data-race="${race.en}">
                <div class="race-inner">
                    <div class="race-front">
                        <div class="r-rank">#${race.r}</div>
                        <div class="r-piece">${race.piece}</div>
                        <div class="r-name-en">${race.en}</div>
                        <div class="r-name-cn">${race.cn}</div>
                    </div>
                    <div class="race-back">
                        <div class="race-desc">${race.desc}</div>
                    </div>
                </div>
            </div>`;
        }).join('');
    },
    /* 聊天表情条：不用改 HTML，这里自动插入 */
    initEmojiBar(){
        const wrapper=document.querySelector('.chat-input');
        if(!wrapper) return;
        const bar=document.createElement('div');
        bar.className='chat-emoji-bar';
        const emojis=['(≧▽≦)','(๑•̀ㅂ•́)و✧','orz','😂','❤️'];
        emojis.forEach(e=>{
            const span=document.createElement('span');
            span.textContent=e;
            span.onclick=()=>social.insertEmoji(e);
            bar.appendChild(span);
        });
        wrapper.insertBefore(bar, wrapper.querySelector('.btn'));
    }
};

/* ================== THE GREAT WAR: TACTICS (AI EVOLUTION) ================== */

const chessGame = {
    boardSize: 10,
    matchId: null,
    myRole: 'blue',
    currentTurn: 'blue',
    gameMode: 'pve',
    difficulty: 'normal', // easy, normal, hard, lunatic
    
    selectedUnit: null,
    units: [],
    deadUnits: [],
    logs: [],
    boardEl: null,
    pollInterval: null,
    isProcessing: false,

    // ================= 16 种族：数值与技能 (原著平衡版) =================
    prototypes: {
        'OldDeus':   { hp: 350, atk: 60, def: 15, rng: 3, mov: 2, icon: '♔', name: '神灵种', desc: '【神击】范围毁灭打击。(CD:5)', skill: { type: 'aoe', range: 3, power: 1.5, initialCd: 2, maxCd: 5, name: 'God Strike' } },
        'Phantasma': { hp: 150, atk: 40, def: 5,  rng: 2, mov: 3, icon: '♕', name: '幻想种', desc: '【相位】无限移动。(CD:4)', skill: { type: 'buff_mov', power: 10, initialCd: 1, maxCd: 4, name: 'Phase Shift' } },
        'Dragonia':  { hp: 250, atk: 70, def: 10, rng: 1, mov: 4, icon: '♖', name: '龙精种', desc: '【崩啸】自残AOE。(CD:3)', skill: { type: 'aoe_self_dmg', range: 2, costHpPct: 0.3, power: 2.5, initialCd: 0, maxCd: 3, name: 'Roar' } },
        'Elemental': { hp: 100, atk: 45, def: 0,  rng: 4, mov: 3, icon: '♗', name: '精灵种', desc: '【魔炮】直线轰炸。(CD:3)', skill: { type: 'line_atk', range: 9, power: 1.2, initialCd: 1, maxCd: 3, name: 'Mana Blast' } },
        'Gigant':    { hp: 200, atk: 35, def: 12, rng: 1, mov: 2, icon: '♜', name: '巨人种', desc: '【地裂】范围眩晕。(CD:3)', skill: { type: 'aoe_stun', range: 1, power: 0.8, initialCd: 1, maxCd: 3, name: 'Quake' } },
        'Flügel':    { hp: 120, atk: 55, def: 3,  rng: 3, mov: 5, icon: '🪽', name: '天翼种', desc: '【天击】自晕高伤。(CD:6)', skill: { type: 'nuke_self_stun', range: 4, power: 3.0, initialCd: 2, maxCd: 6, name: 'Heaven Strike' } },
        
        'Elf':       { hp: 90,  atk: 30, def: 0,  rng: 3, mov: 3, icon: '🧝', name: '森精种', desc: '【六重术式】护盾。(CD:4)', skill: { type: 'buff_def_aoe', range: 3, power: 15, initialCd: 1, maxCd: 4, name: 'Kūgan' } },
        'Dwarf':     { hp: 100, atk: 40, def: 8,  rng: 2, mov: 2, icon: '⚒️', name: '地精种', desc: '【髓爆】自爆。(CD:0)', skill: { type: 'suicide_bomb', range: 2, power: 4.0, initialCd: 0, maxCd: 99, name: 'E-Bomb' } },
        'ExMachina': { hp: 130, atk: 35, def: 8,  rng: 2, mov: 3, icon: '🤖', name: '机凯种', desc: '【伪典·天击】直线 2.0倍 伤害。(CD:5)', skill: { type: 'line_atk', range: 8, power: 2.0, initialCd: 2, maxCd: 5, name: 'Pseudomorph' } },
        'Fairy':     { hp: 70,  atk: 15, def: 0,  rng: 3, mov: 4, icon: '🧚', name: '妖精种', desc: '【自然之息】群疗。(CD:3)', skill: { type: 'heal_aoe', range: 3, power: 60, initialCd: 1, maxCd: 3, name: 'Nature Heal' } },
        'Demonia':   { hp: 140, atk: 38, def: 2,  rng: 1, mov: 3, icon: '👹', name: '妖魔种', desc: '【狂暴】自残再动。(CD:3)', skill: { type: 'act_again_dmg', costHp: 20, initialCd: 1, maxCd: 3, name: 'Berserk' } },
        'Dhampir':   { hp: 90,  atk: 28, def: 0,  rng: 1, mov: 4, icon: '🧛', name: '吸血种', desc: '【吸血】攻击回血。(CD:2)', skill: { type: 'drain_aoe', range: 1, power: 1.0, initialCd: 0, maxCd: 2, name: 'Drain' } },
        'Lunamana':  { hp: 80,  atk: 25, def: 0,  rng: 3, mov: 3, icon: '🌙', name: '月咏种', desc: '【静寂】沉默。(CD:3)', skill: { type: 'debuff_silence', range: 3, initialCd: 1, maxCd: 3, name: 'Silence' } },
        'Warbeast':  { hp: 110, atk: 32, def: 3,  rng: 1, mov: 5, icon: '🐾', name: '兽人种', desc: '【血坏】扣除15%HP，移动+3且再次行动。(CD:4)', skill: { type: 'buff_mov_act', costHpPct: 0.15, power: 3, initialCd: 1, maxCd: 4, name: 'Blood Break' } },
        'Seiren':    { hp: 80,  atk: 20, def: 0,  rng: 2, mov: 2, icon: '🧜', name: '海栖种', desc: '【梦之歌】沉睡。(CD:4)', skill: { type: 'debuff_sleep', range: 2, initialCd: 1, maxCd: 4, name: 'Lullaby' } },
        'Imanity':   { hp: 70,  atk: 15, def: 0,  rng: 1, mov: 3, icon: '♟️', name: '人类种', desc: '【盟约】全员加攻。(CD:5)', skill: { type: 'buff_atk_global', power: 10, initialCd: 0, maxCd: 5, name: 'Aschente' } }
    },

    init() {
        this.boardEl = document.getElementById('game-board');
        this.boardEl.style.gridTemplateColumns = `repeat(${this.boardSize}, 60px)`;
        this.boardEl.style.gridTemplateRows = `repeat(${this.boardSize}, 60px)`;
        this.renderBoardGrid();
        if(!this.matchId) this.log("System Ready.", "system");
    },

    // ================= 游戏开始 =================
    async startGame(mode) {
        this.gameMode = mode;
        this.units = [];
        this.deadUnits = [];
        this.logs = [];
        this.selectedUnit = null;
        this.isProcessing = false;
        document.getElementById('game-log').innerHTML = '';
        
        // 难度选择UI处理
        const diffSel = document.getElementById('pve-difficulty-selector');
        if(mode === 'pve') {
            diffSel.style.display = 'block';
            this.difficulty = document.getElementById('game-difficulty').value;
        } else {
            diffSel.style.display = 'none';
        }

        const overlay = document.getElementById('game-result-overlay');
        if(overlay) { overlay.style.opacity = 0; overlay.style.pointerEvents = 'none'; }

        if (mode === 'pve') {
            this.myRole = 'blue';
            this.currentTurn = 'blue';
            if (this.pollInterval) clearInterval(this.pollInterval);
            this.setupAllUnits();
            this.log(`PVE Started. Difficulty: ${this.difficulty.toUpperCase()}`, "system");
            this.updateUI();
        } else {
            if (!state.isLoggedIn) return alert("Login required.");
            
            // 修复：强制要求输入房间号，确保好友能匹配
            const roomId = prompt("Enter Room ID (e.g. 'ROOM1'):\n[Share this ID with your friend]");
            if (!roomId) return;

            this.log(`Connecting to [${roomId}]...`, "system");
            const res = await apiRequest({ action: 'game_create', custom_id: roomId }); 
            
            if (res.status === 'waiting') {
                this.matchId = res.matchId;
                this.myRole = 'blue';
                this.log(`Room Created. Waiting for P2...`, "system");
                this.setupAllUnits(); 
                this.networkSync();
            } else if (res.status === 'matched') {
                this.matchId = res.matchId;
                this.myRole = 'red';
                this.log(`Joined Room! VS ${res.opponent}`, "system");
                await this.networkPoll(true); // 立即拉取初始数据
            } else if (res.status === 'reconnected') {
                this.matchId = res.matchId;
                this.myRole = res.role;
                this.log(`Reconnected as ${res.role.toUpperCase()}`, "system");
                await this.networkPoll(true);
            } else {
                alert(res.message || "Connection Error");
                return;
            }
            
            if (this.pollInterval) clearInterval(this.pollInterval);
            this.pollInterval = setInterval(() => this.networkPoll(), 3000);
        }
    },

    setupAllUnits() {
        const keys = Object.keys(this.prototypes);
        // Blue (Bottom)
        keys.forEach((key, i) => this.spawnUnit(key, 'blue', i<8?i+1:i-7, i<8?9:8));
        // Red (Top)
        keys.forEach((key, i) => this.spawnUnit(key, 'red', i<8?i+1:i-7, i<8?0:1));
        this.assignStarGrail();
    },

    spawnUnit(type, team, x, y) {
        const p = this.prototypes[type];
        x = Math.max(0, Math.min(this.boardSize-1, x));
        y = Math.max(0, Math.min(this.boardSize-1, y));
        
        this.units.push({
            id: Date.now() + Math.random(),
            type: type, team: team,
            x: x, y: y,
            maxHp: p.hp, hp: p.hp,
            atk: p.atk, def: p.def || 0,
            rng: p.rng, mov: p.mov,
            icon: p.icon, name: p.name, desc: p.desc,
            skill: { ...p.skill, cd: p.skill.initialCd || 0 }, // 应用初始CD
            status: null, hasActed: false, isGrail: false,
            hasMoved: false, // ⭐ 新增：记录本回合是否已移动
            stats: { damageDealt: 0, healingDone: 0, damageTaken: 0 }
        });
    },

    assignStarGrail() {
        const blues = this.units.filter(u => u.team === 'blue');
        const reds = this.units.filter(u => u.team === 'red');
        if(blues.length) this.applyGrailBuff(blues[Math.floor(Math.random()*blues.length)]);
        if(reds.length) this.applyGrailBuff(reds[Math.floor(Math.random()*reds.length)]);
    },

    applyGrailBuff(u) {
        u.isGrail = true;
        u.name = `★ ${u.name}`;
        u.maxHp += 300; u.hp = u.maxHp;
        u.atk = Math.floor(u.atk * 1.5);
        u.def += 15;
        this.log(`Grail Holder: [${u.name}]`, 'system');
    },

    // ================= 玩家操作 =================
    handleTileClick(x, y) {
        if (this.isProcessing) return;
        if (this.gameMode === 'pvp_online' && this.currentTurn !== this.myRole) return;
        if (this.gameMode === 'pve' && this.currentTurn === 'red') return;

        const clicked = this.getUnitAt(x, y);

        if (this.selectedUnit && !this.selectedUnit.hasActed) {
            if (['stun', 'sleep'].includes(this.selectedUnit.status)) {
                this.selectedUnit = null; this.updateUI(); return;
            }
            if (clicked && clicked.team !== this.selectedUnit.team) {
                if (this.isInRange(this.selectedUnit, x, y, 'attack')) return this.actionAttack(this.selectedUnit, clicked);
            } // 移动到空地 (⭐ 修复：必须没移动过才能移动)
            else if (!clicked && !this.selectedUnit.hasMoved) {
                if (this.isInRange(this.selectedUnit, x, y, 'move')) return this.actionMove(this.selectedUnit, x, y);
            }
        }

        if (clicked && clicked.team === this.myRole && !clicked.hasActed) {
            this.selectedUnit = clicked; this.updateUI();
        } else if (!clicked) {
            this.selectedUnit = null; this.updateUI();
        }
    },

    // ================= 技能逻辑 (修复作用域 + CD) =================
    useSkill() {
        const u = this.selectedUnit;
        if (!u || u.hasActed) return;
        if (u.skill.cd > 0) return this.log(`Skill Cooldown: ${u.skill.cd} turns.`, 'system');
        if (u.status === 'silence') return this.log(`${u.name} is Silenced!`, 'system');

        const s = u.skill;
        let used = false;
        let endAct = true; // ⭐ 修复变量名：统一使用 endAct 

        this.log(`${u.name} casts [${s.name}]!`, 'skill');

        // --- 1. 再动类 (血坏 / 狂暴 / 相位) ---
        if (['buff_mov_act', 'act_again_dmg', 'buff_invincible'].includes(s.type)) {
            // 计算代价
            let cost = 0;
            if (s.costHp) cost = s.costHp;
            if (s.costHpPct) cost = Math.floor(u.maxHp * s.costHpPct);

            if(cost > 0) {
                u.hp -= cost; 
                u.stats.damageTaken += cost;
                this.showPopup(u.x, u.y, `-${cost}`, "#f00");
                if(u.hp <= 0) { this.checkDeath(u); return; }
            }
            
            // 效果应用
            if (s.type === 'buff_mov_act') u.mov += s.power; // 血坏加移动
            if (s.type === 'buff_invincible') u.mov += 10;   // 相位无限移动

            this.showPopup(u.x, u.y, "ACT AGAIN", "#f00");
            u.hasActed = false; // ⭐ 关键：重置行动状态
            endAct = false;     // ⭐ 关键：不结束回合
            u.hasMoved = false; // ⭐ 修复：允许再次移动
            used = true;
        }
        
        // --- 2. 机凯种：伪典·天击 (直线激光) ---
        else if (s.type === 'line_atk') {
            this.units.forEach(t => { 
                // 判断是否在同一行或同一列
                if (t.team !== u.team && ((t.x===u.x && Math.abs(t.y-u.y)<=s.range)||(t.y===u.y && Math.abs(t.x-u.x)<=s.range))) {
                    this.applyDamage(u, t, u.atk * s.power);
                }
            });
            used = true;
        }

        // --- 3. 天翼种：天击 (自晕高伤) ---
        else if (s.type === 'nuke_self_stun') {
            let target = this.findNearestEnemy(u); // 自动索敌最近
            if(target && this.getDist(u,target) <= s.range) {
                this.applyDamage(u, target, u.atk * s.power);
                u.status = 'stun'; // 下回合无法行动
                this.showPopup(u.x, u.y, "WEAKENED", "#ccc");
                used = true;
            } else {
                this.log("No target in range!", "system");
            }
        }

        // --- 4. 范围/攻击/治疗/Buff (通用逻辑) ---
        else if (['aoe','aoe_true','aoe_stun','heal_aoe','buff_def_aoe','drain_aoe','aoe_self_dmg','debuff_sleep','debuff_silence'].includes(s.type)) {
            // 自残逻辑 (龙精种)
            if (s.type === 'aoe_self_dmg') { 
                const cost = Math.floor(u.maxHp * s.costHpPct);
                u.hp -= cost; this.showPopup(u.x, u.y, `-${cost}`, "#f00");
            }

            this.units.forEach(t => {
                if (this.getDist(u, t) <= s.range) {
                    if (t.team !== u.team) { // 对敌
                        if (['aoe','aoe_true','aoe_stun','drain_aoe','aoe_self_dmg'].includes(s.type)) {
                            const ignore = s.type === 'aoe_true';
                            const dmg = this.applyDamage(u, t, u.atk * s.power, ignore);
                            if(s.type==='drain_aoe') { // 吸血
                                u.hp = Math.min(u.maxHp, u.hp + dmg); 
                                this.showPopup(u.x, u.y, "+HP", "#0f0"); 
                            }
                        }
                        if (s.type==='aoe_stun') { t.status='stun'; this.showPopup(t.x, t.y, "STUN", "#ff0"); }
                        if (s.type==='debuff_sleep') { t.status='sleep'; this.showPopup(t.x, t.y, "ZZZ", "#ccc"); }
                        if (s.type==='debuff_silence') { t.status='silence'; this.showPopup(t.x, t.y, "SILENCE", "#888"); }
                    } else if (t.team === u.team) { // 对友
                        if (s.type==='heal_aoe') { 
                            t.hp = Math.min(t.maxHp, t.hp + s.power); 
                            u.stats.healingDone += s.power;
                            this.showPopup(t.x, t.y, `+${s.power}`, "#0f0"); 
                        }
                        if (s.type==='buff_def_aoe') { 
                            t.def += s.power; 
                            this.showPopup(t.x, t.y, "DEF UP", "#00f"); 
                        }
                    }
                }
            });
            used = true;
        }
        
        // --- 5. 自爆 (地精种) ---
        else if (s.type === 'suicide_bomb') {
            this.units.forEach(t => { if(t.id!==u.id && this.getDist(u,t)<=s.range) this.applyDamage(u,t,u.atk*s.power); });
            u.hp = 0; u.stats.damageTaken += 999;
            this.checkDeath(u);
            used = true;
        }
        
        // --- 6. 全局Buff (人类种) / 自身Buff (机凯种解析备用) ---
        else if (s.type === 'buff_atk_self') { u.atk = Math.floor(u.atk * s.power); this.showPopup(u.x, u.y, "ATK UP", "#f00"); used=true; }
        else if (s.type === 'buff_atk_global') { 
            this.units.forEach(t => { 
                if (t.team === u.team) { 
                    t.atk += s.power; 
                    this.showPopup(t.x, t.y, "ATK UP", "#0ff"); 
                }
            }); 
            used = true; 
        }

        if (used) {
            u.skill.cd = u.skill.maxCd; // 设置冷却
            if (endAct) { 
                u.hasActed = true; 
                this.selectedUnit = null; 
            } else {
                this.selectedUnit = u; // 再动保持选中
                this.updateUI();       // 立即刷新 UI 以显示新范围
            }
            
            this.updateUI();
            this.checkWin();
            if (this.gameMode === 'pvp_online') this.networkSync();
        }
    },

    actionMove(u, x, y) {
        u.x = x; u.y = y;
        u.hasMoved = true; // ⭐ 修复：标记已移动，防止无限连走
        
        // 检查是否还有敌人
        const hasEnemy = this.units.some(t => t.team !== u.team && this.isInRange(u, t.x, t.y, 'attack'));
        
        // ⭐ 修复逻辑：
        // 如果移动后没有敌人，但技能可用且不是被动，不要立即结束回合，给玩家放技能的机会
        // 只有当 (无敌人 AND (无技能 OR 技能CD中)) 时才自动结束
        const canUseSkill = u.skill && u.skill.cd === 0 && u.status !== 'silence' && !['passive'].includes(u.skill.type);
        
        if (!hasEnemy && !canUseSkill) {
            u.hasActed = true;
            this.selectedUnit = null;
        } else {
            // 保持选中，更新UI让玩家可以选“攻击”或“技能”
            this.selectedUnit = u;
        }
        
        this.updateUI();
        if (this.gameMode === 'pvp_online') this.networkSync();
    },

    actionAttack(atk, def) {
        this.applyDamage(atk, def, atk.atk);
        atk.hasActed = true;
        this.selectedUnit = null;
        this.updateUI();
        this.checkWin();
        if (this.gameMode === 'pvp_online') this.networkSync();
    },

    applyDamage(src, target, amount, ignoreDef=false) {
        let def = ignoreDef ? 0 : target.def;
        let dmg = Math.floor(amount - def);
        if (dmg < 1) dmg = 1;
        target.hp -= dmg;
        
        src.stats.damageDealt += dmg;
        target.stats.damageTaken += dmg;

        this.showPopup(target.x, target.y, `-${dmg}`, '#ff2a6d');
        this.log(`${src.name} hits ${target.name} (${dmg})`);
        
        if (target.status === 'sleep') target.status = null;
        this.checkDeath(target);
        return dmg;
    },

    checkDeath(unit) {
        if (unit.hp <= 0) {
            this.log(`${unit.name} Eliminated!`, 'kill');
            this.deadUnits.push(unit); // 移入墓地
            this.units = this.units.filter(u => u.id !== unit.id);
        }
    },

    // ================= 智能 AI 系统 (核心修复) =================
    async aiTurn() {
        this.log(`Enemy Phase (${this.difficulty.toUpperCase()})...`, "system");
        const aiUnits = this.units.filter(u => u.team === 'red');
        const targetGrail = this.units.find(u => u.team === 'blue' && u.isGrail);

        for (const ai of aiUnits) {
            // 跳过无法行动的单位
            if (ai.hp <= 0 || ['stun','sleep'].includes(ai.status)) continue;

            // 1. 决策目标 (根据难度选择)
            let target = null;
            if (this.difficulty === 'lunatic' || this.difficulty === 'hard') {
                // 高级AI：优先打星杯持有者，其次打残血
                target = targetGrail || this.findWeakestEnemy(ai);
            } else if (this.difficulty === 'normal') {
                // 普通AI：只打最近的
                target = this.findNearestEnemy(ai);
            } else {
                // 简单AI：随机选择一个蓝方单位
                const blues = this.units.filter(u => u.team === 'blue');
                if(blues.length) target = blues[Math.floor(Math.random()*blues.length)];
            }

            if (!target) continue;

            // 2. 攻击判定 (优先使用技能)
            if (this.isInRange(ai, target.x, target.y, 'attack')) {
                await this.wait(400);
                
                // 技能使用概率 (难度越高越爱用技能)
                let skillProb = 0.2; // Easy/Normal
                if(this.difficulty === 'hard') skillProb = 0.5;
                if(this.difficulty === 'lunatic') skillProb = 0.9;

                // 尝试使用伤害类技能
                if (ai.skill.cd === 0 && Math.random() < skillProb && 
                   ['aoe','nuke','line_atk','aoe_self_dmg'].includes(ai.skill.type)) {
                    this.selectedUnit = ai; 
                    this.useSkill();
                } else {
                    this.actionAttack(ai, target);
                }
                continue; // 攻击后结束本单位行动
            }

            // 3. 移动决策 (寻路)
            let bestX = ai.x, bestY = ai.y;
            
            if (this.difficulty === 'easy') {
                // Easy: 随机乱走
                const moves = this.getValidMoves(ai);
                if(moves.length) {
                    const m = moves[Math.floor(Math.random()*moves.length)];
                    bestX = m.x; bestY = m.y;
                }
            } else {
                // Normal/Hard/Lunatic: 逼近目标
                let minDst = 999;
                const moves = this.getValidMoves(ai);
                
                // 寻找能打到人的位置，或者离目标最近的位置
                moves.forEach(m => {
                    const d = this.getDist(m, target);
                    // Lunatic AI 会尝试保持最大射程风筝 (暂简化为贴脸)
                    if(d < minDst) { minDst = d; bestX = m.x; bestY = m.y; }
                });
            }

            // 执行移动
            if (bestX !== ai.x || bestY !== ai.y) {
                await this.wait(300);
                ai.x = bestX; ai.y = bestY;
                this.updateUI();
                
                // 移动后再次尝试攻击
                if (this.isInRange(ai, target.x, target.y, 'attack')) {
                    await this.wait(300);
                    this.actionAttack(ai, target);
                }
            }
            ai.hasActed = true;
        }

        // 所有单位行动完毕
        await this.wait(500);
        
        // ⭐ 关键修复：先解锁，再切换回合
        this.isProcessing = false; 
        this.endTurn(); 
        
        this.log("Player Turn.", "system");
    },

    // 辅助：寻找血量最低的敌人 (Hard/Lunatic 专用)
    findWeakestEnemy(u) {
        let target = null, minHp = 9999;
        this.units.forEach(t => {
            if (t.team !== u.team) {
                // 距离优先权重：如果两个都残血，打近的
                const dist = this.getDist(u, t);
                const score = t.hp + (dist * 2); 
                if(score < minHp) { minHp = score; target = t; }
            }
        });
        return target;
    },
    // 辅助函数 (已补全)
    findNearestEnemy(u) {
        let target = null, min = 999;
        this.units.forEach(t => {
            if (t.team !== u.team) {
                let d = this.getDist(u, t);
                if (t.isGrail) d -= 5; 
                if(d < min){ min = d; target = t; }
            }
        });
        return target;
    },
    // 辅助：获取所有合法移动格 (用于 AI 寻路)
    getValidMoves(u) {
        let moves = [];
        for (let my = u.y - u.mov; my <= u.y + u.mov; my++) {
            for (let mx = u.x - u.mov; mx <= u.x + u.mov; mx++) {
                // 越界检查
                if (mx < 0 || mx >= this.boardSize || my < 0 || my >= this.boardSize) continue;
                // 距离检查 (曼哈顿距离)
                if (this.getDist({x:mx,y:my}, u) > u.mov) continue;
                // 碰撞检查 (不能有其他人)
                if (this.getUnitAt(mx, my)) continue;
                
                moves.push({x:mx, y:my});
            }
        }
        return moves;
    },

    // ================= 回合/结算/网络 =================
    endTurn() {
        if (this.isProcessing) return;
        if (this.currentTurn !== this.myRole && this.gameMode === 'pvp_online') return;

        this.selectedUnit = null;
        const next = (this.currentTurn === 'blue') ? 'red' : 'blue';
        this.currentTurn = next;
        
        this.units.forEach(u => { 
            if (u.team === next) {
                u.hasActed = false;
                u.hasMoved = false; // ⭐ 修复：重置移动状态
                if(u.skill.cd > 0) u.skill.cd--;
                if (u.status === 'stun') { u.status = null; u.hasActed = true; this.showPopup(u.x, u.y, "RECOVER", "#fff"); }
            }
        });

        this.updateUI();

        if (this.gameMode === 'pve' && next === 'red') {
            this.isProcessing = true;
            setTimeout(() => this.aiTurn(), 1000);
        } else if (this.gameMode === 'pve' && next === 'blue') {
            this.isProcessing = false;
        } else {
            this.networkSync();
        }
    },

    checkWin() {
        const blueGrail = this.units.find(u => u.team === 'blue' && u.isGrail);
        const redGrail = this.units.find(u => u.team === 'red' && u.isGrail);
        let winner = null;
        if (!blueGrail) winner = 'red';
        else if (!redGrail) winner = 'blue';

        if (winner) {
            const isVictory = (this.myRole === winner);
            if(this.pollInterval) clearInterval(this.pollInterval);
            this.isProcessing = true;

            const overlay = document.getElementById('game-result-overlay');
            const title = document.getElementById('game-result-title');
            const desc = document.getElementById('game-result-desc');
            const tbody = document.getElementById('game-result-tbody');
            
            overlay.style.opacity = 1;
            overlay.style.pointerEvents = 'all';
            
            title.innerText = isVictory ? "VICTORY" : "DEFEAT";
            title.style.color = isVictory ? "var(--cyan)" : "var(--pink)";
            desc.innerText = isVictory ? "The Star Grail is yours." : "The Star Grail has been lost.";

            const all = [...this.units, ...this.deadUnits];
            all.sort((a,b) => b.stats.damageDealt - a.stats.damageDealt);
            
            tbody.innerHTML = all.map(u => {
                const color = u.team === 'blue' ? 'var(--cyan)' : 'var(--pink)';
                const status = u.hp <= 0 ? '<span style="color:#666">DEAD</span>' : '<span style="color:#0f0">ALIVE</span>';
                return `
                <tr style="border-bottom:1px solid #333;">
                    <td style="padding:8px;color:${color}">${u.icon} ${u.name}</td>
                    <td style="padding:8px;color:#ff6c9c">${u.stats.damageDealt}</td>
                    <td style="padding:8px;color:#9cffd0">${u.stats.healingDone}</td>
                    <td style="padding:8px;color:#aaa">${u.stats.damageTaken}</td>
                    <td style="padding:8px;">${status}</td>
                </tr>`;
            }).join('');
        }
    },

    async networkPoll(force=false) {
        if (!this.matchId) return;
        if (!force && this.currentTurn === this.myRole) return;

        const res = await apiRequest({ action: 'game_poll', matchId: this.matchId });
        if (res.status === 'success') {
            if (force || res.turn === this.myRole) {
                if(!force) this.log("Your Turn!", "system");
                this.currentTurn = res.turn;
                if (res.state) { 
                    this.units = res.state.units || []; 
                    this.deadUnits = res.state.deadUnits || [];
                    this.logs = res.state.logs || []; 
                }
                if (this.currentTurn === this.myRole) {
                    this.units.forEach(u => { 
                        if(u.team === this.myRole) {
                            u.hasActed = false;
                            if(u.skill.cd > 0) u.skill.cd--;
                        }
                    });
                }
                this.updateUI();
                this.checkWin();
            }
        }
    },
    async networkSync() {
        await apiRequest({
            action: 'game_move', matchId: this.matchId,
            state: JSON.stringify({ units: this.units, deadUnits: this.deadUnits, logs: this.logs }),
            nextTurn: this.currentTurn
        });
    },

    // ================= UI / Utils =================
    updateUI() {
        this.renderUnits();
        this.renderRanges();
        this.updateSidePanel();
        const turnText = document.getElementById('game-turn-text');
        turnText.innerText = (this.currentTurn === this.myRole) ? "YOUR TURN" : "OPPONENT TURN";
        if(this.gameMode === 'pve' && this.currentTurn === 'red') turnText.innerText = "ENEMY TURN";
        turnText.style.color = this.currentTurn === 'blue' ? "var(--cyan)" : "var(--pink)";
    },
    renderBoardGrid() {
        this.boardEl.innerHTML = '';
        for (let y = 0; y < this.boardSize; y++) {
            for (let x = 0; x < this.boardSize; x++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.x = x; tile.dataset.y = y;
                tile.onclick = () => this.handleTileClick(x, y);
                this.boardEl.appendChild(tile);
            }
        }
    },
    renderUnits() {
        document.querySelectorAll('.unit').forEach(e => e.remove());
        this.units.forEach(u => {
            const tile = this.getTile(u.x, u.y);
            if (tile) {
                const el = document.createElement('div');
                el.className = `unit team-${u.team}`;
                if (u.hasActed) el.classList.add('done');
                if (this.selectedUnit && this.selectedUnit.id === u.id) el.classList.add('active');
                if (['stun','sleep'].includes(u.status)) el.style.filter = 'hue-rotate(240deg) grayscale(0.8)';
                if (u.isGrail) { el.style.boxShadow = `0 0 25px 5px ${u.team==='blue'?'#00ffff':'#ff0055'}`; el.style.border = "3px solid #fff"; el.style.zIndex="20"; }
                el.innerText = u.icon;
                const hpPct = Math.max(0, (u.hp / u.maxHp) * 100);
                el.innerHTML += `<div class="u-hp-mini"><div class="u-hp-fill" style="width:${hpPct}%"></div></div>`;
                tile.appendChild(el);
            }
        });
    },
    renderRanges() {
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('range-move', 'range-attack'));
        if (this.selectedUnit && !this.selectedUnit.hasActed && !['stun','sleep'].includes(this.selectedUnit.status)) {
            const u = this.selectedUnit;
            for (let y = 0; y < this.boardSize; y++) {
                for (let x = 0; x < this.boardSize; x++) {
                    const dist = Math.abs(x - u.x) + Math.abs(y - u.y);
                    const t = this.getTile(x, y);
                    const target = this.getUnitAt(x, y);
                    // ⭐ 修复：只有没移动过 (hasMoved=false) 才显示移动范围
                    if (!target && dist <= u.mov && !u.hasMoved) t.classList.add('range-move');
                    if (target && target.team !== u.team && dist <= u.rng) t.classList.add('range-attack');
                }
            }
        }
    },
    updateSidePanel() {
        const p = document.getElementById('unit-info-panel');
        const u = this.selectedUnit;
        if (u) {
            p.style.opacity = 1;
            document.getElementById('u-name').innerText = u.name;
            document.getElementById('u-race').innerText = u.type + (u.isGrail ? " [GRAIL]" : "");
            document.getElementById('u-hp-text').innerText = `${u.hp}/${u.maxHp}`;
            document.getElementById('u-hp-bar').style.width = `${Math.max(0, (u.hp/u.maxHp)*100)}%`;
            document.getElementById('u-avatar').innerText = u.icon;
            document.getElementById('u-avatar').style.borderColor = u.team === 'blue' ? 'var(--cyan)' : 'var(--pink)';
            document.getElementById('u-desc').innerText = u.desc;
            document.getElementById('u-atk').innerText = u.atk;
            document.getElementById('u-rng').innerText = u.rng;
            document.getElementById('u-mov').innerText = u.mov;
            const btn = document.getElementById('btn-skill');
            if(btn) {
                const cdTxt = u.skill.cd > 0 ? ` (${u.skill.cd})` : "";
                btn.innerText = `SKILL: ${u.skill.name}${cdTxt}`;
                btn.disabled = u.hasActed || u.status === 'silence' || u.skill.cd > 0 || ['stun','sleep'].includes(u.status);
                btn.style.opacity = btn.disabled ? 0.5 : 1;
            }
        } else { p.style.opacity = 0; }
    },
    getTile(x, y) { return document.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`); },
    getUnitAt(x, y) { return this.units.find(u => u.x === x && u.y === y); },
    getDist(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); },
    isInRange(u, x, y, type) {
        const dist = Math.abs(x - u.x) + Math.abs(y - u.y);
        return type === 'move' ? dist <= u.mov : dist <= u.rng;
    },
    log(msg, type='') {
        const box = document.getElementById('game-log');
        const t = new Date().toTimeString().split(' ')[0];
        box.innerHTML += `<div class="log-entry ${type}">[${t}] ${msg}</div>`;
        box.scrollTop = box.scrollHeight;
    },
    showPopup(x, y, txt, color) {
        const tile = this.getTile(x, y);
        if (tile) {
            const p = document.createElement('div');
            p.className = 'dmg-popup'; p.innerText = txt; p.style.color = color;
            tile.appendChild(p); setTimeout(() => p.remove(), 1000);
        }
    },
    wait(ms) { return new Promise(r => setTimeout(r, ms)); }
};

/* ================== 启动 ================== */

document.addEventListener('DOMContentLoaded',async ()=>{
    visuals.init();

    const stored=sessionStorage.getItem('ngnlUser');
    if(stored){
        try{
            const obj=JSON.parse(stored);
            state.user={...state.user,...obj};
            state.isLoggedIn=true;
            ui.elements.authOverlay.classList.remove('active');
            ui.elements.body.classList.remove('auth-active');
            ui.updateHUD();
            ui.updateProfileView();
            const res=await apiRequest({action:'get_profile'});
            if(res.status==='success') applyProfileFromServer(res.profile);

            // 初始化番剧页面
            animePage.ensureReady();
        }catch(e){
            console.error(e);
            sessionStorage.removeItem('ngnlUser');
            ui.elements.body.classList.add('auth-active');
            ui.elements.authOverlay.classList.add('active');
        }
    }else{
        ui.elements.body.classList.add('auth-active');
        ui.elements.authOverlay.classList.add('active');
    }
});

</script>
</body>
</html>